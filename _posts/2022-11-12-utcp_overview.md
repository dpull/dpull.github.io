---
layout: post
title: Unreal传输层协议---概况
categories: [general]
tags: [unreal, socket]
---

传输层是国际标准化组织提出的开放系统互连(OSI)参考模型中的第四层.该层协议为网络端点主机上的进程之间提供了可靠, 有效的报文传送服务.

比较常见的传输层协议是`UDP`和`TCP`.

## 用户数据报协议(UDP)

UDP是一个简单的传输层协议.
应用进程往UDP套接字写入一个消息, 该消息随后被封装(encapsulating)到一个UDP数据报, 
该UDP数据报进而又被封装到一个IP数据报, 然后发送到目的地.

UDP**不保证UDP数据报会到达其最终目的地**, **不保证各个数据报的先后顺序跨网络后保持不变**, 也**不保证每个数据报只到达一次**.

使用UDP进行网络编程所通到的问题是它**缺乏可靠性**.
如果一个数据报到达了其最终目的地, 但是校验和检测发现有错误, 
或者该数据报在网络传输途中被丢弃了, 它就无法被投递给UDP套接字, 也不会被源端自动重传.
如果想要确保一个数据报到达其目的地, 可以往应用程序中添置一大堆的特性: 来自对端的确认, 本端的超时与重传等.

每个UDP数据报都有一个长度.如果一个数据报正确地到达其目的地, 那么该数据报的长度将随数据一道传递给接收端应用进程.

UDP提供无连接的(connectionless)服务, 因为UDP客户与服务器之间不必存在任何长期的关系.
举例来说, 一个UDP客户可以创建一个套接字并发送一个数据报给一个给定的服务器, 然后立即用同一个套接字发送另一个数据报给另一个服务器.
同样地, 一个UDP服务器可以用同一个UDP套接字从若干个不同的客户接收数据报, 每个客户一个数据报.

## 传输控制协议(TCP)
TCP是一个面向连接的协议, 为用户进程提供可靠的全双工字节流.

TCP提供客户与服务器之间的连接(connection).TCP客户端先与某个给定服务器建立一个连接, 再跨该连接与那个服务器交换数据, 然后终止这个连接.

TCP提供了可靠性(reliability).当TCP向另一端发送数据时, 它要求对端返回一个确认.
如果没有收到确认, TCP就自动重传数据并等待更长时间.在数次重传失败后, TCP才放弃.

TCP含有用于动态估算客户和服务器之间的往返时间(round-trip time, RTT)的算法, 以便它知道等待一个确认需要多少时间.

TCP通过给其中每个字节关联一个序列号对所发送的数据进行排序(sequencing).
举例来说, 假设一个应用写2048字节到一个TCP套接字, 导致TCP发送2个分节: 
第一个分节所会数据的序列号为1一1024, 第二个分节所售数据的序列号为1025一2048.(分节是TCP传递给IP的数据单元)
如果这些分节非顺序到达, 接收端TCP将先根据它们的序列号重新排序, 再把结果数据传递给接收应用.
如果接收端TCP接收到来自对端的重复数据譬如说对端认为一个分节已丢失并因此重传, 而这个分节并没有真正丢失, 只是网络通信过于拥挤, 
它可以(根据序列号)判定数据是重复的, 从而丢弃重复数据.

TCP提供流量控制(flow control).
TCP总是告知对端在任何时刻它一次能够从对端接收多少字节的数据, 这称为滑动窗口(advertised window).
在任何时刻, 该窗口指出接收组冲区中当前可用的室间量, 从而确保发送端发送的数据不会使接收缓冲区溢出.
该窗口时刻动态变化: 当接收到来自发送端的数据时, 窗口大小就减小, 但是当接收应用从缓冲区中读取数据时, 窗口大小就增大.

TCP满足大部分业务的需求, 也是目前最主要应用的传输层协议, 但它存在几个问题:

1. TCP在内核中实现, 应用程序只能使用不能修改.
1. 网络迁移需要重新建立TCP连接, 比如从蜂窝网络切换为Wi-Fi, 需要重新建立连接.
1. 低优先级数据的丢失干扰高优先级数据的接收, 或同等优先级数据数据流相互干扰, 也就是常说的队头堵塞问题.因为TCP是字节流协议, 必须保证收到的字节数据是完整且有序的, 如果序列号较低的分节在网络传输中丢失了, 即使序列号较高的分节已经被接收了, 应用程序也无法读取到这部分数据.
1. TCP有多种拥塞控制算法, 但无法根据业务状态灵活控制.


## 可靠UDP(RUDP)

为了解决TCP存在的问题, 应用程序使用UDP实现了面向连接的协议, 称为可靠UDP(`RUDP`), 比较出名的实现是`QUIC`协议.它有以下优点:

* 使用 UDP 协议, 不需要三次连接进行握手, 而且也会缩短 TLS 建立连接的时间.
* 连接能够平滑迁移
* 实现动态可插拔, 在应用层实现了拥塞控制算法, 可以随时切换.
* 多路复用, 解决了队头阻塞问题

`QUIC`协议是非常好的协议, 在移动互联网上开始大量使用, 并产生了不错的效果.但在游戏领域又有一些独特的业务场景.比如过时游戏状态的重传问题.

试想一下, 玩家了穿越整个地图去射击玩家A.她开始的时候在位置x=0, 在随后的5秒钟, 跑向位置x=100.
服务器每秒向玩家A发送5个数据包, 每个数据包包含玩家了最新位置的x坐标.
如果服务器发现这些数据包中的任何一个丢失了, 那么都会重传.
这意味着当玩家B接近她的最终位置x=100时, 服务器可能还在重传过时的玩家B在x=0附近的状态数据.
这导致玩家A看到的玩家B位置是非常过时的, 在收到玩家B靠近的信息之前就已经被射中了.

## Unreal传输层

针对这种业务场景, Unreal传输层提供了类似"最终一致性"的传输方案, 主要用于[属性复制](https://docs.unrealengine.com/5.1/zh-CN/property-replication-in-unreal-engine/).采用的方案是数据包传递通知.

基于UDP实现游戏的传输层, 需要支持可靠传输, 可靠性的首要要求是, 有能力知道数据包是否到达目的地.
要做到这一点, 你需要创建某种形式的传递通知模块.
该模块的任务是帮助高层依赖它的模块将数据包发送到远程主机, 然后通知这些模块数据是否到达.
它自己不实现重传, 而是允许每个依赖模块仅仅重传它决定重传的数据.

1. 当传输时, 必须唯一标识和标记每个发送出去的数据包, 这样可以将传递状态与每个数据包关联, 并将这个状态以一种有意义的方式传递给依赖模块.
1. 在接收端, 必须检查传入的数据包, 并针对每个它决定处理的数据包发送一个确认.
1. 回到发送端, 必须处理传入的确认, 并通知依赖模块哪个数据包被接收了和哪个数据包被丢弃了.

该可靠系统也保证了数据包不会被乱序处理.如果旧的数据包在新数据包之后到达, 会丢弃这个数据包.
可以防止了更新的数据包中的新数据被包含在旧数据包中的过时数据意外覆盖.

总结一下, Unreal传输层相较于TCP有着以下优点:

* 应用层三次握手, 断线重连业务无感知.
* 支持多路复用, 不同通道之间无影响.
* 可靠数据和不可靠数据有序执行, 发送端知道哪些数据接收端没有执行

后续将分析一下Unreal传输层是如何实现的, 以及有哪些改进方案.
