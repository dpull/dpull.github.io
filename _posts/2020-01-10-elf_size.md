---
layout: post
title: 初始化为0的数组存放在哪儿?
categories: [general]
tags: []
---

某做硬件的朋友遇到一问题, 他们使用了初始化为0的全局数组, 它导致程序文件过大, 无法写入芯片中.

他们想改为指针, 因为是多重数组, 这样改代码调整的地方挺多,

我建议他们使用未初始化的数组, 因为未初始化的变量放在`.bss段`, 初始化的放在`.data段`. `.bss段`只是为未初始化的全局变量和局部静态变量预留位置, 并不占用文件空间.

于是我做了一个试验, 想向他演示这个方法:

```c
#include <stdio.h>

char* sz = NULL;  // 编译后文件大小 8531
char sz[1024 * 1024 * 16]; // 编译后文件大小 8531
char sz[1024 * 1024 * 16] = {0}; // 编译后文件大小 8531
char sz[1024 * 1024 * 16] = {1}; // 编译后文件大小 16785795

int main(void)
{
    printf("%s\n", sz); 
    return 0;
}
```

朋友的全局数组是初始化为0, 在试验中没有, 为什么出现这个问题?

针对初始化为0和初始化为非0, 使用`objdump -t`查看符号表, 发现当初始化为0时, sz在`.bss段`, 当初始化为非0时, sz才在`.data段`.

```bash
objdump -t a_small | grep sz
0000000000601060 g     O .bss   0000000001000000              sz

objdump -t a_big | grep sz
0000000000601060 g     O .data  0000000001000000              sz
```

通过搜索发现gcc 有`-fno-zero-initialized-in-bss`的编译选项, 增加该编译选项后, sz初始化为0时, 也同样存储在.bss段了.

## 结论

朋友的项目因为启用了`-fno-zero-initialized-in-bss`编译选项, 导致初始化为0的全局数组会存放在`.data段`, 进而导致文件体积变大.