---
layout: post
title: Hero开发笔记-客户端资源更新
categories: [general]
tags: []
---
## 基于AssetBundle的客户端资源 ##

传统使用AssetBundle的方法通常是将工程内的每个可更新的“最小单位”打包，由游戏处理相关的依赖。
当然，如何定义“最小单位”，这个是根据项目需求而定，
比如说一个模型可以是一个“最小单位”，所有模型也可以是一个“最小单位”。

### 第一版 ###
将 场景打包，NPC打包，UI打包，配置文件脚本打包，然后替换相关的包即可实现更新
这样的坏处是:

1. 更新包大
1. 处理依赖复杂

### 第二版 ###
针对更新包大的问题，开发了一个对AssetBundle包差异比较合并工具，可以将老包通过比较小的更新量变为新包，
打包策略为 场景打包，Resource打包，然后将其压缩后，放StreamingAsset
这样的坏处是：

1. 解压速度慢（80Mzip压缩包，解压后180M，小米2需要90秒，iPhone5需要50秒，换成lzma算法也不快）
1. 占用磁盘空间（因为差异工具目前只支持非压缩的assetbundle，压缩会造成耗时更新更久。）

其实占用磁盘空间我认为是可以接受的，但解压速度慢不可接受。

### 第三版 ###
第二版是一个完整更新策略，支持全部资源的更新，可以减少需求只支持Resource资源的更新，
打包策略：默认不打assetbundle包，只是将修改过的文件和其依赖打成assetbundle，利用assetbundle差异比较合并工具进行差异更新。
这样的坏处是：

资源冗余，如果是UI资源变更，可能会引发大量资源打包。
进而可以再优化一下，比如将Resource按依赖打成小包，但我不想接受assetbundle解压带来的性能损失和处理依赖的复杂，当然如果这一版更新包实在大，只好按照这个思路做第四版了。

### 第四版 ###
第三版提出了第四版的思路，但真正的第四版并不是按照这个思路走的。
按照我们的打包思路，Resource已经被打入客户端了，只是因为依赖问题，导致了更新包会大，假设依赖的资源，比如说UI的底图，字体，音效等都没变，那么这些资源是可以在客户端的资源中找到的，但是如果某个资源有文件依赖，则其差异会很大，比如说GameObject资源依赖Component资源，则其无法更新，因为是两种打包思路，文件的FileID和PathID都变了。
