---
layout: post
title: PB序列化出错, 竟是UE增量编译的锅！
categories: [general]
tags: [unreal, protobuf]
---

## Day1

客户端同学找我说游戏现网和他的开发分支偶现protobuf序列化数据出错的问题。

请他在开发分支写了个会自动调用测试函数，该函数首先将数据序列化， 然后将数据返序列化， 并检查字段是否正确。

## Day2

因为开发分支没有ASan版本， 先用valgrind跑了一下发现没有内存问题。


代码结构如下：
`ccs_ai_api.pb`中有一个结构


然后GDB调试测试函数， 发现当pb中某个字段被赋值时，数据就会出错， 不被赋值就不出错了。



将序列化的二进制通过gdb拿到后， 写了一件简单的测试程序加载二进制进行分析， 这儿首先说一下pb序列化数据格式：
字段标识|数据大小|子字段1|...
发现是该字段的大小为0， 所以当该字段没有赋值时，反序列化不会出错， 当字段赋值后， 字段大小为0， 但后面依旧序列化了子字段， 反序列化时就覆盖了兄弟字段， 导致数据出错。 
也就是说， 当该字段被赋值后， 字段大小在序列化时， 写入了0

首先怀疑是内存越界问题， 所以建议关掉优化`OptimizeCode = CodeOptimization.Never;`， 再跑跑valgrind版本看看。
但禁用掉优化后， 问题没有重现。

所以决定不用构建机了， 申请代码权限自己搭建构建环境调试

## Day3

今天取版本， 编译构建项目。。
再等待的过程中， 将代码集成到UE的小工程中， 本地编译没有重现问题， 同时编译了ASan版本执行， 没有发现问题。

## Day4

目前开发分支上的版本是删除掉测试函数的， 我取分支最新版构建成功后， 将测试函数重新开启， 无法重现问题， 
回滚到之前出问题的老版本，发现还是不能重现问题，
这时候客户端同学也将启用测试函数的代码提交了， 于是我更新到最新， 编译后， 本机重现了问题

增加测试代码后， 发现GetCachedSize返回值是正确的， 然后修改pb.cc， 序列化完成字段后， 打印一下当前数据， 修改后发现问题不重现了，
然后将本地的所有改动全回滚掉， 发现问题也不重现了，

于是猜测可能是构建问题， 现在我有了同一份代码的两个版本， 通过GDB看反汇编代码
发现出错版本的
mov    0x114(%r12),%edi
执行完成后， %edi的值为0
正确版本的
mov    0x12c(%r12),%edi
执行完成后， %edi的值为11

将错误版本的 %edi的值通过gdb设置为11后，代码执行正确。

0x114(%r12) 和  0x12c(%r12) 应当是DiffAIStateInfo结构中_cached_size_的偏移值， 
错误版本偏移值是276，正确版本偏移值是300， 当前该版本的DiffAIStateInfo的大小为304， _cached_size_是DiffAIStateInfo最后一个变量， 所以300是对的， 前几天的测试程序的DiffAIStateInfo的大小为280，

0x114(%r12)存在于ccs_ai_api.pb.cc.o， 在构建机器上他的生成日期是5月24日， 但是ccs_ai_state.pb.cc.o的修改日期是5月26日， 因为ccs_ai_api.pb.h依赖了ccs_ai_state.pb.h, 所以在5月26日， 应当重新生成ccs_ai_api.pb.cc.o， 但没有重新生成， 所以造成了偏移值不对的代码。

## Day5

今天主要分析为何`*.pb.cc`在依赖头文件变化后， 没有触发编译的问题， 在UBT的函数`IsActionOutdated`判断源文件是否需要编译的条件有三个
1. 编译命令是否变化
1. 源文件是否变化
1. 依赖的头文件是否有变化

但是`*.pb.cc`的依赖头文件没有被赋值， 因为在`CachePCHUsageForModuleSourceFiles`中给扩展名为`.CPP`的源文件赋值了依赖头文件。

所以我们得到了重现办法：
1. 回滚代码到ccs_ai_state.pb.cc改动前的版本
1. 删除`Intermediate\Build\Linux\...\*.pb.cc.o`
1. 编译，并记录下`ccs_ai_api.pb.cc.o`和`ccs_ai_state.pb.cc.o`的编译时间
1. 更新代码到ccs_ai_state.pb.cc改动后的版本
1. 编译，`ccs_ai_api.pb.cc.o`的编译时间应当不变， 但`ccs_ai_state.pb.cc.o`变为当前时间








