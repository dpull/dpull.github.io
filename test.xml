<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>云风的 BLOG</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/" />
    <link rel="self" type="application/atom+xml" href="http://blog.codingnow.com/atom.xml" />
   <id>tag:blog.codingnow.com,2016://1</id>
    <updated>2016-02-03T10:57:41Z</updated>
    <subtitle>思绪来得快去得也快，偶尔会在这里停留</subtitle>
    <generator uri="http://www.sixapart.com/movabletype/">Movable Type 3.2b5</generator>
 
<entry>
    <title>ejoy2d sprite pack 的空间优化</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2016/02/ejoy2d_sprite_pack_aeoaeo.html" />
    <id>tag:blog.codingnow.com,2016://1.996</id>
    
    <published>2016-02-03T10:38:54Z</published>
    <updated>2016-02-03T10:57:41Z</updated>
    
    <summary>在 ejoy2d 里，我将 sprite 的结构信息储存在一组叫 sprite pack 的结构中。其中包括动画的 frame 数据，sprite 由若干部分组成，每个部分的变换矩阵，对应贴图的编码和坐标等等。 通常这些数据不会太大，所以我建议一次加载到内存就不再删除。而动态生成的 sprite 对象则直接引用这些数据，不必做引用计数。这些数据之间的交叉引用（可以像搭积木一样用很多部件构成复杂的 sprite ）也不需要额外记录。但如果保存了大量的动画信息，或 sprite 是由非常多的小部件构成，数据量也可能非常可观。 在我们的 心动庄园 里，达到了数十 M 内存之多。前几天同事提到这个问题，我便动手做了一点简单的优化，居然省出了几十兆内存。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="优化与技巧" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>在 ejoy2d 里，我将 sprite 的结构信息储存在一组叫 sprite pack 的结构中。其中包括动画的 frame 数据，sprite 由若干部分组成，每个部分的变换矩阵，对应贴图的编码和坐标等等。</p>

<p>通常这些数据不会太大，所以我建议一次加载到内存就不再删除。而动态生成的 sprite 对象则直接引用这些数据，不必做引用计数。这些数据之间的交叉引用（可以像搭积木一样用很多部件构成复杂的 sprite ）也不需要额外记录。但如果保存了大量的动画信息，或 sprite 是由非常多的小部件构成，数据量也可能非常可观。</p>

<p>在我们的 <a href="http://star.ejoy.com">心动庄园</a> 里，达到了数十 M 内存之多。前几天同事提到这个问题，我便动手做了一点简单的优化，居然省出了几十兆内存。</p>
]]>
        <![CDATA[<p>其实方法很简单。在 64bit 平台上，我将 sprite pack 结构中的指针都改成了一个 32bit 的相对 pack 头的偏移量。</p>

<p>在设计之初，我就是把整个 sprite pack 存放在连续单个内存块上的。为之做了一个非常简单的 bump allocator ：资源打包的时候，统计整个要用的内存数量，然后在包加载时就分配出来，然后每个小对象都紧贴在一起保存。这样可以节省下大量小内存块的头，并将常规内存管理中可能出现的内存碎片率减少到零。</p>

<p>由于原本就是连续内存块，<a href="https://github.com/ejoy/ejoy2d/commit/993d09c74ba4b491b9bec56b7af4218ddc616f16">把指针更替成偏移量不需要修改太多代码</a> 。</p>

<p>把指针体积减少一半后，数据结构对齐也会变得更紧凑，在我们公司三个项目实际比对下来后，发现 sprite pack 占内存量大约可以减少 40% 。</p>

<hr />

<p>做次修改后，还获得了一个额外的好处。sprite pack 在内存中已经完全不包含指针，也就是说可以随意在内存中移动了，变得和地址无关。</p>

<p>我们可以在打包时直接把 sprite pack 的内存块直接 dump 到文件，加载时可以绕过 import 过程。想来可以快上不少（还没有测试）。即使不能提高太多性能，我们的资源加载过程会变得和资源文件大小严格相关，也就是说，可以通过资源文件体积来准确预测加载时间，可以实现一个非常匀速准确的 loading 条了。我想这对用户体验来说，是个不错的改善。</p>
]]>
    </content>
</entry>
<entry>
    <title>opengl bug 一则</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2016/02/opengl_vbo_bug.html" />
    <id>tag:blog.codingnow.com,2016://1.995</id>
    
    <published>2016-02-03T09:15:56Z</published>
    <updated>2016-02-03T09:33:11Z</updated>
    
    <summary>这是个老问题，但是公司不同的同学先后被坑，所以必须记录一笔。这样可以增加事后被 google 到的概率，千万别来第三次了。 我原本以为 opengl 在 bind VBO 后，如果修改了 VBO 的数据，是不需要重新 bind VBO 对象的。所以早先的 ejoy2d 在这里的处理就做了一点优化，并没有重复 bind ，可以减少一些 API 调用。 大约在 2015 年 6 月左右，由于需要跟进 mac osx 的系统更新，ejoy2d 增加了对 VAO 的支持。我再修改相关实现的时候发现在某些设备上，出现了 bug 。 当时猜想可能是新的手机的驱动做了一些过去没有做的奇怪的优化。我没有太多确认 opengl 是否对次有要求，不知道是否是驱动的 bug ，不过还是做了一些修改。 在 这个...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="调试" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>这是个老问题，但是公司不同的同学先后被坑，所以必须记录一笔。这样可以增加事后被 google 到的概率，千万别来第三次了。</p>

<p>我原本以为 opengl 在 bind VBO 后，如果修改了 VBO 的数据，是不需要重新 bind VBO 对象的。所以早先的 ejoy2d 在这里的处理就做了一点优化，并没有重复 bind ，可以减少一些 API 调用。</p>

<p>大约在 2015 年 6 月左右，由于需要跟进 mac osx 的系统更新，ejoy2d 增加了对 VAO 的支持。我再修改相关实现的时候发现在某些设备上，出现了 bug 。</p>

<p>当时猜想可能是新的手机的驱动做了一些过去没有做的奇怪的优化。我没有太多确认 opengl 是否对次有要求，不知道是否是驱动的 bug ，不过还是做了一些修改。</p>

<p>在 <a href="https://github.com/ejoy/ejoy2d/commit/0e44f3698db66cec63c93f23c99f501d4c9ff92e#diff-639b1343fac7862af1ab91396ffc79ca">这个 patch</a> 中，我在更新 VBO 的数据后，设置了脏标记，最后提交时会重新 bind VBO 。</p>

<p>当时并没有刻意做为一个独立 commit 提交，所以被同事疏忽了。</p>

<p>前不久，我们的 <a href="http://star.ejoy.com/">心动庄园</a> 在新版锤子手机上出现花屏，同事追查过原因，发现只需要更新 ejoy2d 就解决了。定位了一下原因，就是上面提到的 patch 解决的。</p>

<p>前几天，另一个同事自己用 ejoy2d 开发的小游戏 <a href="https://itunes.apple.com/cn/app/bao-lie-fang-kuai-max-crush/id1018641834?mt=8">爆裂方块</a> 在 360 平台审核时被报告有显示 bug ，又查了好久，今天终于定位到是同一问题。</p>
]]>
        <![CDATA[<p>在同样的问题上浪费时间真是不划算。</p>

<p>所以：</p>

<ol>
<li><p>要勤作记录并让 google 可以检索到。</p></li>
<li><p>开源项目要记得保持同步。</p></li>
</ol>
]]>
    </content>
</entry>
<entry>
    <title>资源包的设计</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2016/01/assets.html" />
    <id>tag:blog.codingnow.com,2016://1.994</id>
    
    <published>2016-01-26T12:28:28Z</published>
    <updated>2016-02-03T09:33:58Z</updated>
    
    <summary>一般游戏会把所需要资源数据打包成一个大文件，游戏运行时可以像访问普通文件一样，访问包内文件。如何打包如何更新资源包，是设计重点。 现在有很多资源包直接使用通用打包（压缩）格式，比如 zip 。也有自行设计的，多半是为了一些特殊需求。比如资源间有引用关系等。如果资源数量过多，通常还会对原始资源文件名做一次 hash 索引，加快包内文件检索效率。像暴雪的 mpq 格式，还有 unity3d 的 asset bundle 格式都是这样的。 一旦资源打包，原始文件名信息就不再需要了。应用程序可以在运行时通过文件名的 hash 值索引到包内文件。（所以第三方的 mpq 解包工具需要提供一份额外的文件名列表）...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏开发" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>一般游戏会把所需要资源数据打包成一个大文件，游戏运行时可以像访问普通文件一样，访问包内文件。如何打包如何更新资源包，是设计重点。</p>

<p>现在有很多资源包直接使用通用打包（压缩）格式，比如 zip  。也有自行设计的，多半是为了一些特殊需求。比如资源间有引用关系等。如果资源数量过多，通常还会对原始资源文件名做一次 hash 索引，加快包内文件检索效率。像暴雪的 mpq 格式，还有 unity3d 的 asset bundle 格式都是这样的。</p>

<p>一旦资源打包，原始文件名信息就不再需要了。应用程序可以在运行时通过文件名的 hash 值索引到包内文件。（所以第三方的 mpq 解包工具需要提供一份额外的文件名列表）</p>
]]>
        <![CDATA[<p>既然是 hash ，那么就应该在包格式设计中考虑 hash 冲突的解决方案。asset bundle 的设计人这方面经验欠缺，他们在生成 Deterministic 包的时候，<a href="http://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.DeterministicAssetBundle.html">遇到 hash 冲突就直接放弃打包</a> 。这显然是不合理的。</p>

<p>对于一般几千个文件的包， 32bit hash 值肯定是够用的，但 hash 冲突绝对不能忽略。</p>

<p>一个简单的方法是加盐做二次 hash 。比如你在打包时发现有两个不同的文件名 A 和 B ，他们的 hash 值相同，比如 hash(A) 和 hash(B) 都是 H 。那么，在文件索引表中，就不应该在 H 名下记录数据，而是记录一个冲突标记，并引用一个 salt 。</p>

<p>然后，无论在打包阶段还是运行阶段，碰到 hash(A) 或 hash(B) 时，先查询到 H ，再重新计算一次 hash(A, salt) 或 hash(B,salt) 。这样就可以得到两个不一样的 hash 值了。</p>

<p>保证 hash(A, salt) 不等于 hash(B, salt) 应该在打包阶段完成，为了得到一致的数据包，salt 不用随机产生，而可以从一个固定串开始递增。反复尝试 salt 直到找到一个合适的串，可以区分 hash 冲突的串。</p>

<p>注意：通常你不应该采取直接把文件名和 salt 串拼接的方式来加盐。因为大部分  hash 算法是基于数据流 hash 的。如果两个串的 hash 值相同，那么在前面或后面连接一个相同的串，同样会冲突。</p>

<p>正确的方法是选择一个直接 seed 的 hash 算法，把 salt 当作 seed ; 或者把 salt 循环 xor 到文件名上也不错。</p>

<hr />

<p><strong>资源包间如果有引用关系怎么办？</strong></p>

<p>包间引用不可以光靠 hash 值，因为 hash 值不是 guid ，很难保证不同的包内文件 hash 严格唯一。一个简单的方法是把对外引用的资源（文件）名单独保存在资源里，并对文件名做一个 hash 索引。这样资源包内向资源包做引用时，先用一个 hash 值应用到文件名，再间接引用到包的外部。</p>

<hr />

<p><strong>patch 应该怎么做？</strong></p>

<p>大部分情况下，我们并不需要把 patch 真的合并到原始包中去。只需要把修改过的文件打一个新包即可。我个人建议 patch 包应该保留完整包的所有文件索引。但如果这个 patch 中并不对老文件做修改，就标记一下该文件不在包内即可。</p>

<p>这样，游戏运行时，可以只加载 patch 包，如果 patch 包指明数据不在包内，再打开前一个版本的资源包，它可能依旧是一个 patch 包，也可以是一个完整的资源包。</p>

<p>如果你的游戏需要频繁更新，那么可以定期生成一个完整资源包，并生成从这个完整版本后每个版本到最新版的 patch 包（这个过程可以通过完善你的工具链在自动进行，只要实现正确，生成 patch 的效率应该是很高的）。用户本地版本如果比这个完整资源包还老，就全量下载；如果版本较新，则只需要下载他的版本到最新版的 patch 包即可。</p>

<hr />

<p><strong>打包工具应该是怎样的？</strong></p>

<p>如果你把打包看成是数据文件的版本维护就清楚了。你需要的是一个类似 git 的工具。</p>

<p>将一个本地目录初始化成资源仓库；</p>

<p>向仓库中添加或删除一个本地文件；</p>

<p>查看当前仓库跟踪了哪些数据文件；</p>

<p>将当前版本打包；</p>

<p>为两个已存在的版本求 diff ，生成 patch ；</p>

<p>利用若干 patch 合成一个完整数据包。</p>
]]>
    </content>
</entry>
<entry>
    <title>嵌入式 lua 中的线程库</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2016/01/lua_threads.html" />
    <id>tag:blog.codingnow.com,2016://1.993</id>
    
    <published>2016-01-17T13:53:49Z</published>
    <updated>2016-01-17T14:13:06Z</updated>
    
    <summary>无论是客户端还是服务器，把 lua 作为嵌入语言使用的时候，都在某种程度上希望把 lua 脚本做多线程使用。也就是你的业务逻辑很可能有多条业务线索，而你希望把它们跑在同一个 lua vm 里。 lua 的 coroutine 可以很好的模拟出线程。事实上，lua 自己也把 coroutine 对象叫做 thread 类型。 最近我在反思 skynet 的 lua 封装时，想到我们的主线程是不可以调用阻塞 api 的限制。即在主干代码中，不可以直接 yield 。我认为可以换一种更好（而且可能更简洁）的封装形式来绕过这个限制，且能简化许多其它部分的代码。 下面介绍一下我的新想法，它不仅可以用于 skynet 也应该能推广到一切 lua 的嵌入式应用（由你自己来编写 host 代码的应用，比如客户端应用）：...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="lua与虚拟机" />
            <category term="语言与设计" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>无论是客户端还是服务器，把 lua 作为嵌入语言使用的时候，都在某种程度上希望把 lua 脚本做多线程使用。也就是你的业务逻辑很可能有多条业务线索，而你希望把它们跑在同一个 lua vm 里。</p>

<p>lua 的 coroutine 可以很好的模拟出线程。事实上，lua 自己也把 coroutine 对象叫做 thread 类型。</p>

<p>最近我在反思 skynet 的 lua 封装时，想到我们的主线程是不可以调用阻塞 api 的限制。即在主干代码中，不可以直接 yield 。我认为可以换一种更好（而且可能更简洁）的封装形式来绕过这个限制，且能简化许多其它部分的代码。</p>

<p>下面介绍一下我的新想法，它不仅可以用于 skynet 也应该能推广到一切 lua 的嵌入式应用（由你自己来编写 host 代码的应用，比如客户端应用）：</p>
]]>
        <![CDATA[<p>我们可以在第一个主模块加载时，在 skynet 中也就是 require "skynet" 这里，启动一个调度器的 coroutine 。</p>

<p>这个 coroutine 只用来管理一个数组，数组里全部是业务逻辑的线程。</p>

<p>这个调度器所属的 coroutine 对应的 <code>lua_State</code> 指针，应该记录在 lua vm 的注册表中，保证只到整个 vm 关闭前都活着，那么，接下来我们就可以放心的把它保存在 host 程序中了。</p>

<p>这样，在 host 程序中，除了原有的代表 vm 以及主线程的 L 之外，我们还有一个代表调度器 coroutine 的 cL 。</p>

<p>启动主逻辑的地方，在创建出 vm 后，通常是加载一个主程序文本，然后使用 <code>lua_resume</code> 运行主线程。如果主线程正常运行结束，则之后不再利用主线程 L 做任何事情；但若主线程被挂起，则把它加到调度线程管理的线程列表组里，之后当作普通业务线程去调度。</p>

<p>我们可以同时提供 lua 及 C API 来向这个数组添加新线程(coroutine) ，调度器的职责是永远在空闲的时候尝试 resume 新添加的线程，以及在外部 IO 消息抵达时去唤醒挂起的线程。这个调度过程中，原来的主线程和其它被创建出来的线程并无区别。</p>

<p>而调度器本身的算法并不需要太复杂，也完全没有必要用 host API 去实现，lua 来编写就完全胜任了。</p>

<hr />

<p>有了这样的多线程机制后，我们可能还需要对 lua 原有的 coroutine 库做一点改造。改造后可以用业务层的 coroutine 和利用 lua coroutine 实现的线程库可以协同工作。<a href="http://blog.codingnow.com/2015/12/skynet_coroutine.html">这个之前我已经写过一篇 blog 了</a> 。</p>
]]>
    </content>
</entry>
<entry>
    <title>基于引用计数的对象生命期管理</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2016/01/reference_count.html" />
    <id>tag:blog.codingnow.com,2016://1.992</id>
    
    <published>2016-01-06T07:37:32Z</published>
    <updated>2016-01-06T08:32:01Z</updated>
    
    <summary>最近在尝试重新写 skynet 2.0 时，把过去偶尔用到的一个对象生命期管理的手法归纳成一个固定模式。 先来看看目前的做法：旧文 对象到数字 ID 的映射 其中，对象在获取其引用传入处理函数中处理时，将对象的引用加一，处理完毕再减一。这就是常见的基于引用计数的对象生命期管理。 常规的做法（包括 C++ 的智能指针）是这样的：对象创建时，引用为 1 （或 0）。每次要传给另一个处地方处理，或保留待以后处理时，就将其引用增加；不再使用时，引用递减。当引用减为 0 （或负数）时，把对象引用的资源回收。 由于此时对象不再被任何东西引用，这个回收销毁过程就可视为安全且及时的。不支持 GC 的语言及用这些语言做出来的框架都用这个方式来管理对象。 这个手法的问题在于，对象的销毁时机不可控。尤其在并发环境下，很容易引发问题。问题很多情况是从性能角度考虑的优化造成的。 加减引用本身是个很小的开销，但所有的引用传递都去加减引用的话，再小的开销也会被累积。这就是为什么大多数支持 GC 的语言采用的是标记扫描的 GC 算法，而不是每次在对象引用传递时都加减引用。 大部分情况下，你能清楚的分辨那些情况需要做引用增减，哪些情况下是不必的。在不需要做引用增减的地方去掉智能指针直接用原始指针就是常见的优化。真正需要的地方都发生在模块边界上，模块内部则不需要做这个处理。但是在 C/C++ 中，你却很难严格界定哪些是边界。只要你不在每个地方都严格的做引用增减，错误就很难杜绝。 使用 id 来取代智能指针的意义在于，对于需要长期持有的对象引用，都用 id 从一个全局 hash 表中索引，避免了人为的错误。（相当于强制从索引到真正对象持有的转换） id 到对象指针的转换可以无效，而每次转换都意味着对象的直接使用者强制做一个额外的检查。传递 id 是不需要做检查的，也没有增减引用的开销。这样，一个对象被多次引用的情况就只出现在对象同时出现在多个处理流程中，这在并发环境下非常常见。这也是引用计数发挥作用的领域。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="skynet" />
            <category term="语言与设计" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>最近在尝试重新写 skynet 2.0 时，把过去偶尔用到的一个对象生命期管理的手法归纳成一个固定模式。</p>

<p>先来看看目前的做法：<a href="http://blog.codingnow.com/2015/04/handlemap.html">旧文 对象到数字 ID 的映射</a></p>

<p>其中，对象在获取其引用传入处理函数中处理时，将对象的引用加一，处理完毕再减一。这就是常见的基于引用计数的对象生命期管理。</p>

<p>常规的做法（包括 C++ 的智能指针）是这样的：对象创建时，引用为 1 （或 0）。每次要传给另一个处地方处理，或保留待以后处理时，就将其引用增加；不再使用时，引用递减。当引用减为  0 （或负数）时，把对象引用的资源回收。</p>

<p>由于此时对象不再被任何东西引用，这个回收销毁过程就可视为安全且及时的。不支持 GC 的语言及用这些语言做出来的框架都用这个方式来管理对象。</p>

<hr />

<p>这个手法的问题在于，对象的销毁时机不可控。尤其在并发环境下，很容易引发问题。问题很多情况是从性能角度考虑的优化造成的。</p>

<p>加减引用本身是个很小的开销，但所有的引用传递都去加减引用的话，再小的开销也会被累积。这就是为什么大多数支持 GC 的语言采用的是标记扫描的 GC 算法，而不是每次在对象引用传递时都加减引用。</p>

<p>大部分情况下，你能清楚的分辨那些情况需要做引用增减，哪些情况下是不必的。在不需要做引用增减的地方去掉智能指针直接用原始指针就是常见的优化。真正需要的地方都发生在模块边界上，模块内部则不需要做这个处理。但是在 C/C++ 中，你却很难严格界定哪些是边界。只要你不在每个地方都严格的做引用增减，错误就很难杜绝。</p>

<hr />

<p>使用 id 来取代智能指针的意义在于，对于需要长期持有的对象引用，都用 id 从一个全局 hash 表中索引，避免了人为的错误。（相当于强制从索引到真正对象持有的转换）</p>

<p>id 到对象指针的转换可以无效，而每次转换都意味着对象的直接使用者强制做一个额外的检查。传递 id 是不需要做检查的，也没有增减引用的开销。这样，一个对象被多次引用的情况就只出现在对象同时出现在多个处理流程中，这在并发环境下非常常见。这也是引用计数发挥作用的领域。</p>

<p>而把对象放在一个集合中这种场景，就不再放智能指针了。</p>

<hr />

<p>长话短说，这个流程是这样的：</p>

<p>将同类对象放在一张 hash 表中，用 id 去索引它们。</p>

<p>所有需要持有对象的位置都持有 id 而不是对象本身。</p>

<p>需要真正操作持有对象的地方，从 hash 表中用 id 索引到真正的对象指针，同时将指针加一，避免对象被销毁，使用完毕后，再将对象引用减一。</p>

<p>前一个步骤有可能再 id 索引对象指针时失败，这是因为对象已经被明确销毁导致的。操作者必须考虑这种情况并做出相应处理。</p>

<hr />

<p>看，这里销毁对象的行为是明确的。设计系统的人总能明确知道，我要销毁这个对象了。 而不是，如果有人还在使用这个对象，我就不要销毁它。在销毁对象时，同时有人正在使用对象的情况不是没有，并发环境下也几乎不能避免。（无法在销毁那一刻通知所有正在操作对象的使用者，操作本身多半也是不可打断的）但这种情况通常都是短暂的，因为长期引用一个对象都一定是用 id 。</p>

<p>了解了现实后，“当对象的引用为零时就销毁它” 这个机制是不是有点怪怪的了？</p>

<p>明明是：我认为这个对象已经不需要了，应该即使销毁，但销毁不应该破坏当下正在使用它的业务流程。</p>

<hr />

<p>这次，我使用了另一个稍微有些不同的模式。</p>

<p>每个对象除了在全局 hash 表中保留一个引用计数外，还附加了一个销毁标记。这个标记只在要销毁时设置一次，且不可翻转回来。</p>

<p>现在的流程就变成了，想销毁对象时，设置 hash 表中关联的销毁标记。之后，检查引用计数。只有当引用计数为 0 时，再启动销毁流程。</p>

<p>任何人想使用一个对象，都需要通过 hash 表从 id 索引到对象指针，同时增加引用计数，使用完毕后减少引用。</p>

<p>但，一旦销毁标记设置后，所有从 id 索引到对象指针的请求都会失败。也就是不再有人可以增加对象的引用，引用计数只会单调递减。保证对象在可遇见的时间内可被销毁。</p>

<p>另外，对象的创建和销毁都是低频率操作。尤其是销毁时机在资源充裕的环境下并不那么重要。所以，<strong>所有的对象创建和销毁都在同一线程中完成</strong>，看起来就是一个合理的约束了。 尤其在 actor 模式下， actor 对象的管理天生就应该这么干。</p>

<p>有了单线程创建销毁对象这个约束，好多实现都可以大大简化。</p>

<p>那个维护对象 id 到指针的全局 hash 表就可以用一个简单的读写锁来实现了。索引操作即对 hash 表的查询操作可遇见是最常见的，加读锁即可。创建及销毁对象时的增删元素才需要对 hash 表上写锁。而因为增删元素是在同一线程中完成的，写锁完全不会并发，对系统来说是非常友好的。</p>

<p>对于只有唯一一个写入者的情况，还存在一个小技巧：可以在增删元素前，复制一份 hash 表，在副本上慢慢做处理。只在最后一个步骤才用写锁把新副本交换过来。由于写操作不会并发，实现起来非常容易。</p>
]]>
        

    </content>
</entry>
<entry>
    <title>skynet 消息队列的新设计(接上文)</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2016/01/skynet_mq.html" />
    <id>tag:blog.codingnow.com,2016://1.991</id>
    
    <published>2016-01-06T03:30:34Z</published>
    <updated>2016-01-06T08:26:33Z</updated>
    
    <summary>接前一篇文 ，谈谈 skynet 消息队列的一些新想法。 之前谈到，每个服务的消息接收队列可以是定长的，且不必太长。因为正常运行中，每个服务都应该尽量消化掉需要处理的消息，否则会预示着某种上层设计的问题。 但是，在接收队列满的时候直接丢掉消息显然是不合理的。那意味着必须有更健全的错误传播机制，让发送失败方可以出错而中断业务。允许发送消息出错可能使上层结构设计更难。 让发送方阻塞在 skynet 中显然也不是个好方案。因为 skynet 的服务是允许阻塞时重入执行另一条新 session 的，这是和 erlang 最大的不同。这可以让单个 lua vm 的性价比更高，可以在要需要的时候，做共享状态，而不必全部业务都通过相对低效的消息通讯来完成；但其负面代价是重入会引发一些隐讳的 bug 。很多已有的 skynet 项目都依赖 send 消息不阻塞这点来保证逻辑正确，不能轻易修改。 我的解决方案是给每个服务再做一组发送队列。最接收方忙的时候，把待发消息放在自己这里的发送队列中。这样就可以由框架来确保消息都能正确的依次发送（这里不保证目的地不同的消息的先后次序，但保证目的地相同的消息次序）。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="skynet" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p><a href="http://blog.codingnow.com/2016/01/skynet2.html">接前一篇文</a> ，谈谈 skynet 消息队列的一些新想法。</p>

<p>之前谈到，每个服务的消息接收队列可以是定长的，且不必太长。因为正常运行中，每个服务都应该尽量消化掉需要处理的消息，否则会预示着某种上层设计的问题。</p>

<p>但是，在接收队列满的时候直接丢掉消息显然是不合理的。那意味着必须有更健全的错误传播机制，让发送失败方可以出错而中断业务。允许发送消息出错可能使上层结构设计更难。</p>

<p>让发送方阻塞在 skynet 中显然也不是个好方案。因为 skynet 的服务是允许阻塞时重入执行另一条新 session 的，这是和 erlang 最大的不同。这可以让单个 lua vm 的性价比更高，可以在要需要的时候，做共享状态，而不必全部业务都通过相对低效的消息通讯来完成；但其负面代价是重入会引发一些隐讳的 bug 。很多已有的 skynet 项目都依赖 send 消息不阻塞这点来保证逻辑正确，不能轻易修改。</p>

<p>我的解决方案是给每个服务再做一组发送队列。最接收方忙的时候，把待发消息放在自己这里的发送队列中。这样就可以由框架来确保消息都能正确的依次发送（这里不保证目的地不同的消息的先后次序，但保证目的地相同的消息次序）。</p>
]]>
        <![CDATA[<hr />

<p>这两天，我仔细考虑了这个方案。从单一接收队列改为一个接收队列和若干发送队列。实现复杂度一定是增加了，但并没有达到不可接受的程度。这个方案并不难想到，也不难做到，但 3 年前实现 skynet  时我并没有这么做，一定是有些原因吧。</p>

<p>其中一个核心问题是，处理 IO 和 timer 的线程不同于普通的服务，它们是和系统打交道的。也按类似的机制做就不太合理了。它们要做的是尽量匀速的接收外部消息，并马上转发到 skynet 内部，它们是面对几乎所有 skynet 内部服务高频工作的。不应该有复杂的调度机制。</p>

<p>ps. IO 和 timer 线程也不是普通的 skynet 服务。我曾经把 IO 做成一个独立服务，后来又放弃了这个做法而移到核心中去。</p>

<p>一个变通的方法是让两个特殊的定制服务和 IO 及 timer 线程对 1 对 1 对接。对接的通道是无限长的，由于只有一个读取方一个接收方，这个消息队列在实现时也可以有针对性。</p>

<hr />

<p>另一个问题是，在服务退出时如果处理遗留消息。</p>

<p>我们必须让未处理的请求被妥善回应。在 skynet 1.0 中，这个步骤是在上层完成的。lua 层会在 exit 时遍历所有没有回应的请求，发送一个 error 消息。</p>

<p>而当发送消息不再保证送达时，问题就变得有点棘手。在新方案中，未发出的消息是暂存在自己的发送队列中的，一旦自己都不在，谁来保证这些消息送达呢？</p>

<p>同样的问题还有：当暂发请求真正发出的时候，对方已经退出，需要重新产生一个错误回应。</p>

<p>我的解决方案是：首先在底层就严格区分请求/回应/单向推送/错误传播 这些消息，可以直接在底层做出合理处理；然后让服务的销毁也严格放在唯一一个服务中进行。在销毁过程中，收集待发消息队列，采集这些消息，然后将需要处理的放在自己这里，之后持续发送。</p>

<p>关于服务的创建和销毁部分。我有许多新想法，打算另开一篇 blog 来记录。</p>

<hr />

<p>总结一下，这篇主要谈消息队列的新设计。在消息队列方面，我计划按需定制三类队列。</p>

<p>第一，多写一读的固定长度并发队列。由于只有一个读者，且队列长度固定不变。所以在出队列的一端是不需要任何锁的。锁只放在进队列的一端。但这里并不需要无锁设计来减少 spin lock 的盲等。因为任何一个写入者碰到队列满或队列有别的写入者正在操作，都可以一致视为队列忙，不必反复重试。它只需要把待发数据放在自己的发送队列即可。</p>

<p>第二，读写全在一起的无并发队列。用来暂存在接收方忙时的待发数据（还会用于服务销毁时收集待办业务）。这个队列可以在 OOM 未发生前无限增长。因为无并发情况，很容易实现正确。每个服务将配备多个这样的队列。这个待发队列不会用得太多，所以默认长度会很短，多个队列也不需要用 hash 表索引，简单一个数组即可。需要用时直接 O(n) 遍历（n 不会太大，因为过载可能的服务并不会太多，多的话系统根本不能正常工作）。</p>

<p>第三，专用于 IO 线程及 timer 线程和 skynet 内部服务对接的一读一写队列（管道）。写入方和读取方分属不同线程。这个队列有可能按需增长。这个可以用一个读写锁来保证并发正确。写锁只发生在写入队列满时，读取方每次读操作都需申请读锁。注意，这里队列满的扩展队列操作同时只有一个操作者，所以不必锁住队列后再做复制扩展队列空间；而可以扩展前先对老队列做一个副本并行处理，再用写锁做一个新老指针交换。</p>

<hr />

<p>最后，昨天我实在忍不住光在脑子里想，刷了一天的代码（大约 1000 行完全新写的）。</p>

<p>好吧，我食言了，等不到年后了。skynet 2.0 重写计划开始了一天。新代码暂时只能编译通过，还不完整，不能运行。我暂放在一个<a href="https://github.com/cloudwu/skynet2">临时仓库</a>里，等合适的时候再合并到 skynet 主仓库的 2.0 分支上。</p>

<p>有兴趣的同学可以帮忙 review 一下，印证一下这两篇 blog 的想法的具体实现。</p>
]]>
    </content>
</entry>
<entry>
    <title>skynet 消息分发及服务调度的新设计</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2016/01/skynet2.html" />
    <id>tag:blog.codingnow.com,2016://1.990</id>
    
    <published>2016-01-04T11:40:20Z</published>
    <updated>2016-01-04T12:24:09Z</updated>
    
    <summary>这个月 skynet 的 1.0 就会 release 最终版了，除了维护这个稳定版本。我考虑可以对一些不太满意的地方尝试做大刀阔斧的改变（当然不放在目前的稳定版本中）。 我对 skynet 解决的核心问题：多服务任务调度以及内部消息传播这块不是很满意，觉得如果换个方式实现可能会好一些。下面先把想法记下来。 目前，每个服务都有一个唯一的消息队列，且在内存足够的前提下，会无限增长。也就是说，向一个服务发消息是没有失败的可能的。多数情况下，单个服务的消息队列不会太长，在生产消费模型中，也不允许太长。太长意味着消费速度远远低于生产速度，情况多半会恶化。在历史上发生过多起事故，都是和服务过载 有关。 虽然 skynet 提供了 mqlen 这种方法供使用者查询当前服务的消息队列长度，以做出应变，但治标不治本。我想做一个大的设计改动来重新考虑这一块。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="skynet" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>这个月 skynet 的 1.0 就会 release 最终版了，除了维护这个稳定版本。我考虑可以对一些不太满意的地方尝试做大刀阔斧的改变（当然不放在目前的稳定版本中）。</p>

<p>我对 skynet 解决的核心问题：多服务任务调度以及内部消息传播这块不是很满意，觉得如果换个方式实现可能会好一些。下面先把想法记下来。</p>

<p>目前，每个服务都有一个唯一的消息队列，且在内存足够的前提下，会无限增长。也就是说，向一个服务发消息是没有失败的可能的。多数情况下，单个服务的消息队列不会太长，在生产消费模型中，也不允许太长。太长意味着消费速度远远低于生产速度，情况多半会恶化。在历史上发生过多起事故，都是和<a href="http://blog.codingnow.com/2014/10/skynet_overload.html">服务过载</a> 有关。</p>

<p>虽然 skynet 提供了 mqlen 这种方法供使用者查询当前服务的消息队列长度，以做出应变，但治标不治本。我想做一个大的设计改动来重新考虑这一块。</p>
]]>
        <![CDATA[<p>我们可以把每个服务的消息队列实现成固定长度，且固定长度并不需要太长，大约 256 个 slot 这种级别就足够了。一个固定长度的循环队列实现起来要简单的多，且很容易做成进出队列互不影响。因为出队列只发生在一个服务内，不可能并发，根本不需要考虑竞争；而仅仅只需要考虑进队列的竞争问题。</p>

<p>当队列满，或有人在入队列操作时，都认为队列忙，不需要做锁，直接失败即可。遇到忙的时候发送方可以自行缓存代发数据。而多方同时写入队列时，对 skynet 来说，其实不需要保证先后次序，有时序要求的仅仅是同一发送者对一个特定接受者。在队列不忙时，谁先写都是没问题的；且同一服务下，当有多个待发出队列时，先处理哪一个也不太所谓。</p>

<p>这样就可以把消息进出这块的所有竞争都去掉，实现起来也非常简单。而且可以大大缓解服务过载后的雪崩问题。因为退出一些有未发出消息的服务，那些没有发出的消息也自然被扔掉了。而目前的设计则会将所有消息都堆积在一条消息队列中，这些消息在玩家频繁上下线时会有大量无效信息。</p>

<p>这里提到的新设计比现在复杂的一点是，该什么时候唤醒一个服务。在现有的情况下，只有一个服务获得新消息，且不在热服务队列中，它才会把自己压入热服务队列，待工作线程去处理。而做出以上改变后，一个服务又未发出的消息时，也需要在接收方解除拥塞后唤醒。</p>

<p>我的想法是索性把服务的任务调度也一并改进。采用一个更简单更粗暴的方式来做。</p>

<p>目前其实把服务分成两类的，一类是热服务，就是有消息待处理的；另一类是冷服务，服务活着，但消息队列暂时为空。工作线程只要从热服务队列中依次取出服务调用回调函数即可。</p>

<p>这么设计是考虑到热服务的数量通常远小于总的服务数量，如此能减少工作线程轮询一个服务是否有消息可处理的开销。</p>

<p>是不是可以考虑另一种算法呢？</p>

<p>每个工作线程可以重复一个工作循环。</p>

<p>第一步就是遍历所有的服务，挑选出当前有事情要做（包括有消息要处理，有消息发出被拥塞）的服务，去掉正在被别的工作线程处理的那些（服务忙），把这些服务放在当前工作线程下的一个集合中。</p>

<p>第二步，依次处理自己集合中的服务消息。在处理工作中，如果碰到别的工作线程已经在处理，或消息队列空，或待发队列依然无法处理（接收方拥塞）则立刻将该服务从自己的集合中去掉。</p>

<p>由于移出集合的条件很宽松，而不会加入新的元素，所以只要不断循环第二步，自己所属的集合会越来越小。但为了防止某几个服务霸占工作线程，还可以加一个循环次数上限，相当于让过热的服务有个冷却的机会。</p>

<p>当第二步的集合为空，或是达到了循环上限。那么结束这个工作循环，回到第一步继续。</p>

<hr />

<p>以上是一些初步的想法，晾到年后再动手实现。</p>
]]>
    </content>
</entry>
<entry>
    <title>Skynet 1.0.0 RC 版发布</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2015/12/skynet_rc.html" />
    <id>tag:blog.codingnow.com,2015://1.989</id>
    
    <published>2015-12-28T06:02:08Z</published>
    <updated>2015-12-28T06:46:01Z</updated>
    
    <summary>拖了很久，终于决定给 skynet 1.0.0 封版了。比预期的时间 足足晚了半年，好在还是在 2015 年把这个事情启动了。 其实已经很久没有对已有特性做修改了，如果的项目是在今年 3 月份以后跟进的 1.0 alpha 版的话，升级到目前的最新版本应该不会有太大痛苦。最近几个月几乎没有增加新的特性，反而是在裁减一些多余的，用的人不多的东西（为了兼容，把这样一些 API 移到了一些独立的模块中，方便废弃）。 据我所知，skynet 用于的商业游戏项目（以及一些非游戏项目）早已经超过了 2 位数，收获了不错的口碑。它不再是我们自己公司的内部项目，持续收到不同人的 PR 说明很多同学不仅仅在使用，更是用心在 review 代码，让它真正成为一组公众视野下的代码。我相信这是开源的终极意义：众目睽睽之下， Bug 无所遁形。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="skynet" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>拖了很久，终于决定给 <a href="https://github.com/cloudwu/skynet">skynet</a> 1.0.0 封版了。比<a href="http://blog.codingnow.com/2015/02/skynet_10_plans.html">预期的时间</a> 足足晚了半年，好在还是在 2015 年把这个事情启动了。</p>

<p>其实已经很久没有对已有特性做修改了，如果的项目是在今年 3 月份以后跟进的 1.0 alpha 版的话，升级到目前的最新版本应该不会有太大痛苦。最近几个月几乎没有增加新的特性，反而是在裁减一些多余的，用的人不多的东西（为了兼容，把这样一些 API 移到了一些独立的模块中，方便废弃）。</p>

<p>据我所知，skynet 用于的商业游戏项目（以及一些非游戏项目）早已经超过了 2 位数，收获了不错的口碑。它不再是我们自己公司的内部项目，持续收到不同人的 PR 说明很多同学不仅仅在使用，更是用心在 review 代码，让它真正成为一组公众视野下的代码。我相信这是开源的终极意义：众目睽睽之下， Bug 无所遁形。</p>
]]>
        <![CDATA[<p>我们自己的项目也从 skynet 开源经营中获益良多。有好几处来源于外部的 bugfix 都是在错误发生前被堵住，只是可惜的是，我们也有项目未能及时跟进，只到真的出错了才回头发现在主干上早已改过。这些事故反而证明了开源对于提高项目质量的作用。</p>

<p>这次发布 1.0.0 正式版本的候选版 (RC) ，并专门公告，就是希望有在使用 skynet 的同学，尤其是已经有项目上线运营的，能够在最后这几天将遗留问题提出来，issue 或 pr 都可以。不要把遗憾留到 1.0.1 :)</p>

<p>我希望这次把 RC 标签保留一个月，在农历新年前换成正式版。</p>

<hr />

<p>对于因为 skynet 常年挂着 alpha （其实 beta 已经一个月了）标签还在犹豫的同学，希望换上正式版标签后可以打消你的疑虑（当然，我个人并不觉得标签换了后，代码质量会有本质变化）。</p>

<p>同时不要再不断的问 “真的有项目用 skynet 的吗？”，“skynet 有文档吗？”。</p>

<p>尤其对于后一个问题，我对连 README 都不看的同学，真的很烦回答啊。</p>

<p>skynet 不仅有 <a href="https://github.com/cloudwu/skynet/wiki/FAQ">FAQ</a> ，也有<a href="https://github.com/cloudwu/skynet/wiki">中文的文档</a>，而且文档更新的还很及时。麻烦你读一下 readme 以及跟着链接去看看 wiki 吧，能问出 skynet 有文档吗这种问题的同学，我相信把文档摆在他面前也是读不下去的，文档对他就没有存在意义。</p>

<hr />

<p>算起来从 2012 年 8 月开源发布（7 月开始写第一行代码）到现在居然已经有 3 年有余。这么一个小小的项目经历了三年，整个过程都有线上运营的项目在紧跟。为了历史兼容问题，必然有无数遗憾。传言 linus 说过，所有项目你都要做两次才明白到底怎么做。</p>

<p>我不知道有没有机会重新来做 skynet 2.0 （目前没有任何这方面的计划），把我认为错误的设计，更好的设计推倒重来一次。至少可以把项目的代码风格统一一点，看起来更漂亮。</p>

<p>但眼下要做的事情仅仅只是：赶紧发布第一个稳定版，让更多的人放心来用。用的人越多，后来人也就越放心。</p>
]]>
    </content>
</entry>
<entry>
    <title>skynet 里的 coroutine</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2015/12/skynet_coroutine.html" />
    <id>tag:blog.codingnow.com,2015://1.988</id>
    
    <published>2015-12-18T07:54:59Z</published>
    <updated>2015-12-18T08:08:27Z</updated>
    
    <summary>skynet 本质上只是一个消息分发器，以服务为单位，给每个服务一个独立的 id ，可以从任意服务向另一个服务发送消息。 在此基础上，我们在服务中接入 Lua 虚拟机，并将消息收发的 api 封装成 lua 模块。目前用 lua 编写的服务在最底层只有一个入口，就是接收并处理一条 skynet 框架转发过来的消息。我们可以通过 skynet.core.callback （这是一个内部 API ，用 C 编写，通常由 skynet.start 调用）把一个 lua 函数设置到所属的服务模块中。每个服务必须设置，且只能设置一个回调函数。这个回调函数在每次收到一条消息时，接收 5 个参数：消息类型、消息指针、消息长度、消息 session 、消息来源。 消息大致分两大类，一类是别人对你发起的请求，一类是你过去对外的请求收到的回应。无论是哪类，都是通过同一个回调函数进入。 在实际使用 skynet 时，你可以直接使用 rpc 的语法，向外部服务发起一个远程调用，等对方发送了回应消息后，逻辑接着走下去。那么，框架是如何把回调函数的模式转换为阻塞 API 调用的形式呢？ 这多亏了 lua 支持...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="lua与虚拟机" />
            <category term="skynet" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>skynet 本质上只是一个消息分发器，以服务为单位，给每个服务一个独立的 id ，可以从任意服务向另一个服务发送消息。</p>

<p>在此基础上，我们在服务中接入 Lua 虚拟机，并将消息收发的 api 封装成 lua 模块。目前用 lua 编写的服务在最底层只有一个入口，就是接收并处理一条 skynet 框架转发过来的消息。我们可以通过 skynet.core.callback （这是一个内部 API ，用 C 编写，通常由 skynet.start 调用）把一个 lua 函数设置到所属的服务模块中。每个服务必须设置，且只能设置一个回调函数。这个回调函数在每次收到一条消息时，接收 5 个参数：消息类型、消息指针、消息长度、消息 session 、消息来源。</p>

<p>消息大致分两大类，一类是别人对你发起的请求，一类是你过去对外的请求收到的回应。无论是哪类，都是通过同一个回调函数进入。</p>

<p>在实际使用 skynet 时，你可以直接使用 rpc 的语法，向外部服务发起一个远程调用，等对方发送了回应消息后，逻辑接着走下去。那么，框架是如何把回调函数的模式转换为阻塞 API 调用的形式呢？</p>

<p>这多亏了 lua 支持 coroutine 。可以让一段代码运行了一半时挂起，在之后合适的时候在继续运行。</p>
]]>
        <![CDATA[<p>为了实现这点，我们需要在收到每条请求消息时，先创建一个 coroutine ，在 coroutine 中去运行该类消息的 dispatch 函数（使用框架时，可通过 skynet.dispatch 设置消息的处理函数）。之所以必须先创建 coroutine 而不能直接调用消息处理函数，是因为我们无法预知在消息处理的过程中会不会因为阻塞 API 而需要挂起执行流程。等到第一次需要挂起时才把执行流程绑定到 coroutine 上是做不到的。</p>

<p>然后，所有的阻塞 API 都是通过 coroutine.yield 挂起当前 coroutine ，并把挂起类型以及可能用到的数据传出来。而框架会捕获住这些参数，也就进一步知道该去做些什么。这也就解释了阻塞 API 为什么必须在消息处理函数中调用，而不能直接写在服务的主体代码中的原因。因为初始化部分的代码并不运行在框架创建出来的 coroutine 中，coroutine.yield 也就无处捕获处理。</p>

<p>例如，对于 skynet.call ，其实是生成了一个对当前服务来说唯一的 session 号调用 yield 给框架发送 "CALL" 这个指令。框架中的 resume 捕获到 "CALL" 后，就会把 session 和 coroutine 对象记录在表中，然后挂起 coroutine ，结束当前的回调函数。等待 skynet 底层框架后后续消息进来时再处理。（实际上，这里还会处理 skynet.fork 创建的额外线程）</p>

<p>当收到回应消息时，会根据 session 号找到之前记录的 coroutine 对象。然后 resume 之前没有做完的业务即可。从应用层角度看起来，就只是一次阻塞调用而已。</p>

<p>以上仅仅是 skynet 在搭建框架时利用 coroutine 把回调转换为阻塞调用用的一种手法，并不是唯一的方案。比如，你还可以不通过 yield 传递任何数据给框架，全部都塞在额外的 table 中。而调度器仅仅在收到 yield 后结束当前的回调函数就够了。但如果这样做，在满足下面的一个需求时，就会遇到一些小麻烦（可能需要借助一些额外的全局标记变量才能搞定）：</p>

<hr />

<p>如果我们希望在 skynet 框架下的消息函数中使用 coroutine 库怎么办？</p>

<p>也就是把 skynet 框架和正常的 coroutine 机制混合使用。如果你直接使用 coroutine ，那么所有 skynet 的阻塞 API 都不能正常工作了。它们会触发 yield ，而被用户你自己写的 resume 捕获到，而不能正确处理。</p>

<p>这时，我们引入了 <a href="https://github.com/cloudwu/skynet/wiki/Coroutine">skynet.coroutine</a> 这个库。你可以用 skynet.coroutine 全面替代 lua 原生的 coroutine 库，api 是一致的。</p>

<p>它所做的事情就是在 yield coroutine 的时候，在传出参数的最前面加上一个 "USER" 类型（也就是在 skynet 框架下，所有的 yield 都必须在第一个参数给出挂起类型），而在 resume coroutine 时，一旦发现是 "USER" 类型时，就去掉这个类型值，而把剩下的参数直接返回，阻止外框架结束消息处理；而如果是其它类型，则向上传播给框架，让框架挂起当前消息处理流程，等待底层的回应再继续。这种做可以让应用层的 coroutine 看起来不被 skynet 框架的阻塞调用所打断。</p>

<p>当然，这还需要给 skynet.coroutine.status 在 "normal" "running" "suspended" "dead" 等类型之外增加一类 coroutine 状态，叫做 "blocked" 。意思是，coroutine 被底层框架挂起，但不可以由引用层 resume 。</p>

<p>这个状态类似于 "normal" ，是 skynet 框架下的一个特例。因为 skynet 框架下两个独立的请求消息处理流程可视为并行的处理线程。线程之间数据是共享的，也意味着一条线程创建的 coroutine 对象对另一线程可见，也可以调用 resume 。而 "blocked" 状态可以阻止错误的 resume 调用。</p>

<p>实现 skynet.coroutine 封装并不算复杂，里面最大的难点其实在于 pofile 对 skynet 线程的时间分析。<a href="https://github.com/cloudwu/skynet/wiki/Profile">profile</a> 会在 yield 的时候暂停计时，而在 resume 时继续。这样才可能正确统计出一个请求的完整流程到底消耗了多少 CPU 时间。而用户 coroutine 的引入会增加统计的复杂性。我们需要跟踪 resume 的调用，回溯到底是哪条消息间接执行了 coroutine 中的代码，才能正确的把耗时加上去。有兴趣了解细节的同学可以直接阅读代码。</p>

<hr />

<p>一般我们不太需要直接使用 coroutine 模块。skynet 本身提供了 skynet.fork() 方法来创建一条新的业务线程，可以用 skynet.wait(co) 来挂起，并用 skynet.wakeup(co) 来唤醒。区别在于 wakeup 只是向框架发送一个信号，需要等框架来调度；而不像 coroutine.resume(co) 会直接延续挂起的 coroutine 。</p>

<p>那么什么时候可能需要使用 coroutine 模块呢？</p>

<p>我认为最大的用途是把 coroutine 作为迭代器来使用。<a href="http://www.lua.org/pil/9.3.html">PIL 里有一个不错的例子</a> 。</p>

<p>正巧半年前我自己也遇到一个实际需求利用 coroutine 实现迭代器，下面分享一下这个案例（和 skynet 关系不大）。</p>

<p>由于 lua 可定制的内存管理器比标准 CRT 的内存管理 api 约定提供更多的信息，以及 lua vm 本身的内存取用工作模式可以被预知，所以有可能定制一个比通用分配器更好的内存管理器。（对于 skynet  还有额外的意义：可以让不同的 lua vm 使用不同区块的内存页，在 vm 关闭时减少内存碎片）</p>

<p>内存管理器写起来容易，想做的稳定放心且判断是否真的更高效却不那么容易。所以我想了一个办法来制作测试用的数据。</p>

<p>我在项目实际运行的环境里定制了一个特别的内存管理器，log 了所有的内存管理器调用行为。在实际项目运行相当长一段时间后，就得到了好多组，每组几 G 的数据。这些数据严格反应了真实项目在运行过程中内存是如何在使用的。</p>

<p>我可以用这些数据严格测试自定义的内存管理模块，它将和线上产品经受完全一致的使用。我可以加上额外的检查，即在分配出内存后填充独有的数据，并在释放的时候严格检查填充。还可以检测任意时间点的碎片率，峰值内存占用情况等等。当然也可以在关掉检测后和标准内存分配器在速度上一较高下。或是针对项目做算法微调以观成效。</p>

<p>只是，直接使用这份 log 数据并不容易。log 中记录的是每次内存配及释放的地址信息。如果我在测试代码中建一张大的 hash 表来动态保存它们有额外的开销，这个开销很可能会对内存分配器性能测量本身造成影响。因为内存分配模块本身运行速度就很快，甚至比 hash 表的实现要快。而且如果是个动态 hash 表，它本身也需要使用内存管理函数，这样干扰就更大了。</p>

<p>我倾向于在测试函数中建一个足够大的静态数组，把测试数据以流式读进去。理论上，数组的大小不会超过实际运行过程中同时存在的内存块条目数量。只要对原始 log 数据做一点处理，把内存地址转换为数组里的序号就好了。</p>

<p>测试程序读取处理过的 log ，只需要知道一条内存分配请求应该放在静态数组的第几项中，而释放请求应该去释放静态数组中的第几项就好了。这样对测试本身的干扰最小。</p>

<p>我的任务就是加工原始 log 。</p>

<p>一开始我想的比较简单，这些 log 也就转换一次而已，随便写个脚本算一下就好了。无非是把整个 log 加载到一个 lua table 里，比对一下地址，转换成编号。</p>

<p>实际做的时候我发现遇到了点小麻烦：log 文件实在是太大了，处理起来迅速超过了我的物理内存上限，变得非常缓慢。随后我想到了用一个 coroutine 做成迭代器，一边处理源数据流一边做转换，一边输出。</p>

<p>虽然不用 coroutine 也可以做到这点，但实现起来会麻烦许多。用 coroutine 完成这些需求非常的自然。如果你不介意读一下我当初随手写的脚本，<a href="https://gist.github.com/cloudwu/6a5ac23a3c86645661fb">可以在 gist 上找到它们</a> 。</p>
]]>
    </content>
</entry>
<entry>
    <title>Rogue&apos;s Tale 基础系统设定</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2015/12/rogues_tale_guide.html" />
    <id>tag:blog.codingnow.com,2015://1.987</id>
    
    <published>2015-12-15T09:05:45Z</published>
    <updated>2015-12-15T12:48:59Z</updated>
    
    <summary>Rogue&apos;s Tale 是个相当不错的硬核 RogueLike 游戏，之前我在 blog 里多次介绍过。前段时间还在 steam 上写了一篇新手上手指南 。这款游戏的系统数值公式设计的非常精巧，在官方主页有详细的英文介绍，对熟悉游戏很有帮助。我选取了一部分基础设定翻译成中文。当然不仅仅是为了玩好游戏，也是对类似游戏的设计有所借鉴。 以下基于 http://rogue.epixx.org/ 翻译 基础系统 2D6 系统 游戏里所有的行动都使用一套统一规则，其行动结果由对比扔出的两个六面骰数字与目标的难度级别来决定。在和目标难度级别做比较前，扔出的数字通常还会做一次增益或惩罚修正，该修正就是简单的加在扔出的数字上。 如果最终修正值大于等于目标难度级，行动成功。如果低于难度级，行动失败。如果骰子扔出两个 1 ，行动被直接视为致命失败而无视修正值。如果骰子扔出两个 6 ，行动则直接判定为暴击而不需要加上修正值和难度级做对比。 属性修正 属性修正在生物依靠属性去做点什么事情的时候起效果。属性修正还用于修正伤害骰以及一些直接或间接针对生物的事件。正的修正被称为增益，负的修正被称为惩罚。 人类的属性修正范围从 -5 到 +5 间线性变化，2 点时修正为 -5 ，7 点时修正为 0 ，12 点时修正为 +5 。属性点可以超过 12 点，此时修正值可以超过...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="游戏" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>Rogue's Tale 是个相当不错的硬核 RogueLike 游戏，之前我在 blog 里多次介绍过。前段时间还在 steam 上写了一篇<a href="http://steamcommunity.com/sharedfiles/filedetails/?id=547810981">新手上手指南</a> 。这款游戏的系统数值公式设计的非常精巧，在官方主页有详细的英文介绍，对熟悉游戏很有帮助。我选取了一部分基础设定翻译成中文。当然不仅仅是为了玩好游戏，也是对类似游戏的设计有所借鉴。</p>

<p>以下基于 <a href="http://rogue.epixx.org/">http://rogue.epixx.org/</a> 翻译</p>

<hr />

<h1>基础系统</h1>

<p><strong>2D6 系统</strong></p>

<p>游戏里所有的行动都使用一套统一规则，其行动结果由对比扔出的两个六面骰数字与目标的难度级别来决定。在和目标难度级别做比较前，扔出的数字通常还会做一次增益或惩罚修正，该修正就是简单的加在扔出的数字上。</p>

<p>如果最终修正值大于等于目标难度级，行动成功。如果低于难度级，行动失败。如果骰子扔出两个 1 ，行动被直接视为致命失败而无视修正值。如果骰子扔出两个 6 ，行动则直接判定为暴击而不需要加上修正值和难度级做对比。</p>

<p><strong>属性修正</strong></p>

<p>属性修正在生物依靠属性去做点什么事情的时候起效果。属性修正还用于修正伤害骰以及一些直接或间接针对生物的事件。正的修正被称为增益，负的修正被称为惩罚。</p>

<p>人类的属性修正范围从 -5 到 +5 间线性变化，2 点时修正为 -5 ，7 点时修正为 0 ，12 点时修正为 +5 。属性点可以超过 12 点，此时修正值可以超过 +5 ，但和其它的增益或惩罚合并后，最终的结果会截取到 +5 再作用于行动（有一些例外：在计算近程和远程伤害时，有些情况例如瞄准射击和致命打击，可以超过 5 )。</p>

<p>其他种族有一些不同的属性基础值，他们的属性修正范围可能超过 -5 到 +5 。比如兽人比人类的平均水平要强壮一些，他们的力量修正范围就是 -4 到 +6 的。更不用说，兽人怪物可以把你一般的冒险角色轻松撕成碎片。</p>
]]>
        <![CDATA[<p><strong>属性检定</strong></p>

<p>每个行动都需要做一种属性检定。属性检定的难度视情况而变化。默认的属性检定难度级别是 7 ，这意味着当 2D6 投出的数字和加上所有修正后结果等于或超过 7 就视为成功。</p>

<p><strong>属性点</strong></p>

<p>所有的生物都由四个属性来影响行动。这四个属性分别是力量、敏捷、耐力和魅力。</p>

<ul>
<li><p><strong>力量(STR)</strong>
力量影响着生物的物理能力。力量修正作用于近战命中骰、近战伤害骰，投掷武器的伤害骰、格档骰、打断检定、陷阱检定，攀爬检定、恐吓鉴定。</p></li>
<li><p><strong>敏捷(AGI)</strong>
敏捷影响着生物的反应和平衡。敏捷修正作用于远程命中骰、远程伤害骰、投掷武器的命中骰、特定武器的近战命中及伤害骰、闪避修正、招架修正、解除陷阱检定、开锁检定、潜行检定以及跳跃检定。</p></li>
<li><p><strong>耐力(STA)</strong>
耐力影响着生物的物理耐久性。耐力修正作用于毁灭性或进攻性的法术命中骰、精神检定、搜索检定、HP、精力点、以及 HP 和精力的回复检定。</p></li>
<li><p><strong>魅力(CHA)</strong>
魅力影响着生物的人格力量。魅力修正作用于恢复或防御性的法术命中骰、说服检定、商品价格，还有机会开启和 NPC 的特殊交互菜单。</p></li>
</ul>

<p><strong>差异三规则</strong></p>

<p>在达到 20 级前，人类的最高和最低属性点差异不可以超过 3 。在 20 级时可获得最后一点属性点，该点属性不受此限制。</p>

<p>对于女性角色有所优待，她们的属性点在最低的属性是力量，其它属性点都比力量高，且最高属性点是魅力时，差异可以是 4 。不过最后一点属性点不能把差异扩大到 5 。</p>

<p><strong>血量</strong></p>

<p>血量决定了生物在被杀死前可以承受多少点伤害。生物的血量 等于它的基础耐力值加上它的基础耐力修正乘以血量 倍率再加上耐力最终修正较基础耐力修正超出的部分。血量倍率基于生物等级，从一级开始每三级加一（1 级、4 级、7级等对应着 1 倍、2 倍、3 倍，依此类推）。</p>

<p>例如，一个 4 级生物，基础耐力为 8，有额外的一点耐力强化，就有 11 点的血量（8 加上 2 倍的基础耐力修正 1 ，再加上 1 点强化而来的耐力修正，这 1 点正是最终耐力修正 2 和基础耐力修正 1 的差值）。</p>

<p>有很多方法来回血，方法不限于法术、天赋、特别技能，以及休息。最廉价的回血方法是先吃饱喝足，然后休息。为了在休息中回血，生物先要确保饥渴两状态中至少有一项是 satiated （饱腹），而另一项不能是 hungry （饥饿）或 thirsty （干渴）。然后每个休息回合用下面的公式来判定该回合是否可以回血：</p>

<p>回血检定：2D6 + 耐力修正 >= 12 （如果吃饱喝足两项满足则为 10）</p>

<p><strong>精力</strong></p>

<p>精力决定了生物在休息前可以发动多少次特殊行动。生物的精力点为它的基础耐力修正加 3 。</p>

<p>当生物休息或移动时，都会用下列公式检定而获得一次精力回复的机会：</p>

<p>精力回复检定：2D6 + 耐力修正 >=7 （移动时为 10 ）</p>

<p><strong>抗性</strong></p>

<p>抗性在承受直接伤害时可获得直接伤害减免，但不能帮助抵抗以受到的效果影响。例如，如果生物被疾病影响，那么只能通过治疗疾病来消除影响或是获得疾病免疫效果。</p>

<p>抗性仅针对下列伤害类型：物理、疾病、毒药、火焰、冰霜、震击。对于魔法伤害和陷阱造成的伤害无法以任何方式抵抗。</p>

<p><strong>免疫</strong></p>

<p>免疫可以避免次生伤害，但对直接伤害不起作用。例如，如果生物对火焰效果免疫，那么他在被火焰法术击中后不会燃烧，但依旧要承受火焰法书造成的伤害。</p>

<p><strong>弱点</strong></p>

<p>针对特定伤害类型的弱点意思是该种伤害会导致双倍伤害值。生物有弱点的话就一定会中次生伤害效果 —— 火焰或导致燃烧，毒伤或导致中毒，等等。同种弱点并不叠加。</p>

<p><strong>气场伤害</strong></p>

<p>有气场的生物会在每回合结束时对所有邻近的生物都造成气场伤害。对于有相同气场的生物邻接在一起时，气场会给生物回血。气场造成的伤害值或回复量为 D3 + 耐力修正。</p>

<p>如果是 monster （怪物）带气场的话，气场半径从 1 增加到 2 ，伤害或回复值乘 1.5 倍。</p>

<p>带气场的生物（例如，火焰、冰霜、震击，等等）将完全免疫和气场相同类型的伤害以及其此生效果。在目标没有对应类型的弱点时，气场不引发次生效果。</p>

<p>注意气场会自动攻击，并不会导致爆击。针对它的抗性取身体和头部装备上抗性和的平均值，并向下取整。</p>

<p><strong>饥渴度</strong></p>

<p>每个生物都会被饥饿和干渴影响。食物和水是生存的必需品，如果缺少它们将影响特定生物的行为。</p>

<p>饥饿和干渴有七种不同的程度表示生物的饥渴度。饥饿和干渴程度是分别计算的。</p>

<p>饥饿条：Famished, Starving, Hungry, Not Hungry, Satiated, Bloated, Choking.</p>

<p>干渴条：Parched, Dehydrated, Thirsty, Not Thirsty, Satiated, Hydrated, Drenched.</p>

<p>每级饥渴条都有内部 360 回合倒数。直接设置等级的法术和效果将会把内部回合数设为 180 。向上或向下调整级别的法术和效果将会把内部回合数分别设为 90 或 270 。吃喝食物则直接调整内部回合数。</p>

<p>任何一个将状态条向下或向上超出的效果（少于 1 会合或超过 2520 回合）都会造成每回合一点的伤害。</p>

<p>对于处于 Famished 或 Parched 两状态其一的生物，在所有基于属性的鉴定或投骰中都要承受 -2 的惩罚，并且无法回复精力。对于处于 Starving, Dehydrated, Choking, Drenched 等任一状态的，所有检定和投骰中都承受 -1 的惩罚。</p>

<p>吃东西可以维持饥饿条，回复的回合数取决于事物的类型和质量。干渴条可以用喝水来维持，回复的回合数取决于饮料的类型和质量。干渴条还可以由含水的食物来回复。</p>

<p>注意，如果不是被诅咒强迫进食，吃喝都会停在 satiated 状态而不会过量。</p>

<p><strong>回合次序</strong></p>

<p>在同一层的所有生物在玩家进入该层时就在预定次序排好了。每个回合一个生物通常只能做一个行动，移动、射击、释放法术、使用天赋等等。</p>

<p>由生物召唤出来的生物会在召唤者之后行动。由环境召唤出来的生物在所有已存在的生物之后行动。</p>

<p><strong>速度效果</strong></p>

<p>一些生物天生加速或迟缓，还有一些魔法效果可以加速或减慢速度。无论来源如何，带有一个或多个加速效果的生物在同一回合有机会行动两次，而迟缓效果则有可能导致它整个回合无法行动。</p>

<p>和每回合的正常行动不同，带有一个或多个加速效果的生物，每个加速效果扔两个六面骰，只要有一次投出 8 或以上则在该回合可以行动两次。此外，带有一个或多个迟缓效果的生物，则需要为每个迟缓效果扔两个六面骰，并以下面的公式检定是否会失去整个回合：</p>

<p>迟缓检定：2D6 + 耐力修正 >= 7 + 效果能级修正</p>

<p>对于加速生物，无论是否通过鉴定，它的饥渴进度条在每个行动上都会消耗 1 加上加速效果的数量倍食物。（例如，带有加速戒指的角色每个行动讲消耗 (1+1) x 2 = 4 个食物和水，当加速效果起作用时一个回合消耗 8 个）。</p>

<p>生物可以同时受多个速度效果影响。这些效果的处理会使得迟缓效果可能取消整个回合的行动而抵消掉所有的加速效果。例如，一个生物被两个加速效果和一个迟缓效果影响时，该生物有可能在同个回合行动行动一次或两次，也可能什么都做不了。</p>

<p><strong>被诅咒的物品</strong></p>

<p>游戏中所有物品都可能被诅咒。被诅咒的物品效果可能只是一些小麻烦，也可能是可怕到直接搞死该生物。不过任何被诅咒的物品上都可能发生两件事。第一件是生物不能出于自己的意志解除对被诅咒物品的持有，第二件是在生物装备了该物品后，直接失败的修正增加 1 。</p>

<p>在多数情况下，对于自由取下的被诅咒物品，只在该物品被装备时诅咒才生效。但有些物品会魔法绑定在装备者身上，这些物品只有通过解除绑定其中的魔法来摧毁掉它。</p>

<p><strong>被祝福的物品</strong></p>

<p>游戏中所有物品都可能被祝福。被祝福的物品有一些隐秘特性，所有被祝福的物品遵循下列设计准则：</p>

<ol>
<li>消费类的物品可以使用更多次 （药水，魔法书、魔杖）。</li>
<li>会损坏的物品更坚固（护甲、头盔、盾牌、武器）。</li>
<li>可装备的物品有更多特性（项链、戒指）。</li>
</ol>

<hr />

<h1>战斗系统</h1>

<p><strong>命中检定</strong></p>

<p>当一个生物攻击另一个生物时，无论是近战还是远程还是法术，都需要做一次命中检定。命中检定用下列公式来判定是否成功：</p>

<ul>
<li>近战命中检定：2D6 + 攻击修正 >= 7 + 防御修正</li>
<li>远程命中检定：2D6 + 攻击修正 >= 7 + 距离修正</li>
<li>法术命中检定：2D6 + 攻击修正 >= 7 + 距离修正</li>
</ul>

<p>对无抵抗能力的生物发起近战攻击将自动命中，且爆击率上升（D6 + 暴击修正 >= 6 ）。生物在睡眠、麻痹、震击、眩晕时失去抵抗能力。</p>

<p>针对隐形生物的近战攻击，基础难度从 7 上调到 12 。隐身状态的生物发起的近战攻击无法被格档、闪避、招架。</p>

<p><strong>命中修正</strong></p>

<p>攻击修正通常等于武器匹配的属性修正。该修正可能对应任何一种属性修正。通常来说，近战武器使用力量修正，远程武器使用敏捷修正、法术使用耐力修正或魅力修正。</p>

<p>防御修正包括闪避修正，以及在装备了对应武器后，可能触发格档或招架修正中的一种。</p>

<p>在没有天赋的情况下，副手近战武器攻击会加上 -2 的命中修正（参见双持）。</p>

<ul>
<li><p><strong>闪避修正</strong>
任何可以完全控制自己行动的生物都可能在同一回合闪避一次攻击。闪避修正取生物的敏捷修正，最低为零，最高由护甲和头盔上列出的最大闪避修正值截断。</p></li>
<li><p><strong>格档修正</strong>
任何可以完全控制自己行动的生物都可能在同一回合使用盾牌格档一次攻击。格档修正取生物的力量修正，最低为零，最高由盾牌上列出的最大格档修正值截断。</p></li>
<li><p><strong>招架修正</strong>
任何可以完全控制自己行动的生物都可能在同一回合使用小型副手武器或双手拿一中型武器来招架一次攻击。招架修正取一半的敏捷修正并向上取整。最高被武器上列出的最大招架修正值截断。</p></li>
<li><p><strong>距离修正</strong>
距离修正等于距离除二并向下取整。例如，如果目标在右侧三格、向上四格处，距离为 sqrt(3^2 + 4^2) ，也就是 5 ，最终的距离修正是 2 。</p>

<ul>
<li><strong>偏斜修正</strong>
偏斜修正等于目标生物装备的盾牌上的最小格档修正。该值在计算攻击者的天赋和装备效果前加在距离修正上。</li>
</ul></li>
</ul>

<p>是否发生闪避，格档或招架由命中骰来决定，只要没有正好投出该类防御修正指定的数值，那么防御修正就还可以用于后续的命中检定。</p>

<p>例如，一个生物在没有任何命中修正时想攻击另一个有 +1 敏捷 +1 力量修正且带盾的生物。攻击方需要扔出 9 来击中，因为防御方这个回合还没有闪避或格档。如果攻击方投出了 8 或 7 ，防御方会格档或闪避掉攻击，并且在该回合中余下的过程失去该形式的防御。假设这个攻击者投出了 8 ，这样防御者就失去了格档机会；下一个攻击者（不带增益修正）就需要投出 8 来命中，此刻防御者只能闪避。</p>

<p>防御修正对应的骰值根据攻击者的增益修正来调整，同时会降低闪避、招架、格档发生的几率。</p>

<p>例如，当一个有 +4 增益修正的生物攻击上面例子中生物，只需要扔出 5 或更大来击中。在这个例子中，格档发生在扔出 4 的时候，闪避发生在扔出 3 的时候。格档概率从 5/36 下降到 3/36 而闪避概率从 6/36 下降到 2/36 。</p>

<p><strong>击中部位</strong></p>

<p>每个生物有两个部位可能被击中，身体和头部。普通攻击击中身体，暴击击中头部。当命中骰等于或超过暴击阀值时，或是投出两个六，都被视为暴击。</p>

<p>默认的暴击阀值为 12 ，但会根据等级差，体积差，以及魔法效果而变化。例如，兽人是一种比人类更大的单位，如果再加上一级的等级差，那么就需要投出 10 ，11 或 12 产生暴击。</p>

<p>无论何时一个生物被暴击，都有一定几率产生混乱。以下公式被用于检定暴击效果：</p>

<p>暴击效果检定：2D6 + 耐力修正 >= 7 + 未被抵抗的伤害</p>

<p>如果检定未通过，生物将混乱检定不够的回合数。注意，即使伤害全部被抵抗，也需要通过检定。</p>

<p><strong>伤害</strong></p>

<p>当攻击成功命中目标，就会造成伤害。伤害的总量取决于武器或是法术，以及对应的伤害修正。</p>

<p>伤害修正通常等于攻击者武器对应的属性修正。修正可以对应于任何一种属性，通常近战和投掷武器使用力量修正，远程武器使用敏捷增益修正，攻击法术使用耐力或魅力修正。</p>

<p>副手近战武器伤害等于两倍的敏捷惩罚修正，或是 -1 ，这取决于哪样更小一些。</p>

<p>双手近战武器以及被双手使用的单手近战武器的修正等于一半的对应属性修正并向上取整，或是 0 ，这取决于哪个更高。</p>

<p>伤害修正还可能包括一项或多项魔法修正。魔法修正不受生物装备武器的形式包括主副手的影响。</p>

<hr />

<h1>天赋系统 </h1>

<p><strong>瞄准射击 (Aimed Shot)</strong></p>

<p>远程攻击每点敏捷增益修正获得 D3 的额外伤害，取代普通的 1 点额外伤害。学习多重射击和快速射击前都必须先学习瞄准射击。</p>

<p><strong>多重射击(Multi Shot)</strong></p>

<p>远程攻击 将命中目标生物邻接的多个额外生物目标，数量等于敏捷增益修正值。多重射击不能用于慢速武器。</p>

<p><strong>快速射击(Quick Shot)</strong></p>

<p>远程攻击的射击前生物可以先移动。快速射击不能用于慢武器。</p>

<p><strong>稳定射击(Steady Shot)</strong></p>

<p>远程攻击时，可以重投失败的命中检定，在隐秘状态下能造成双倍伤害。</p>

<p><strong>剑刃乱舞(Blade Flurry)</strong></p>

<p>近战攻击的每把武器（当敏捷增益修正 +1 或更高时，可针对主手武器；+3 或更高时针对副手武器）获得最一次额外攻击机会。剑刃乱舞需要两把小型武器或将一把中型武器双手使用。</p>

<p><strong>致命投掷(Deadly Throw)</strong></p>

<p>投掷武器攻击的每点属性增益修正获得 D3 额外伤害，取代普通的 1 点额外伤害，依据的属性取力量和敏捷中的较高值。致命投掷使用所有投掷武器攻击时，允许生物使用力量和敏捷修正中较高的那个做命中和伤害修正。</p>

<p><strong>英勇冲锋(Heroic Charge)</strong></p>

<p>允许生物最多移动两格，然后在移动停止后攻击目标。英勇冲锋还会增加 1 点伤害修正。</p>

<p><strong>粉碎打击(Crushing Blow)</strong></p>

<p>主手近战武器攻击的每点力量增益修正都获得 D3 额外伤害，取代普通的 1 点额外伤害。粉碎打击需要一把中型或大型武器。学习致命一击或横扫打击前必须先学习粉碎打击。</p>

<ul>
<li><p><strong>致命一击(Killing Blow)</strong>
主手近战攻击在攻击命中且命中骰投出一对，且目标生物不免疫即死（instant death）时，直接杀死对方。致命一击需要一把中型或大型武器。</p></li>
<li><p><strong>横扫打击(Sweeping Blow)</strong>
主手近战武器将命中和攻击者邻接的多个额外生物目标，其数量取决于力量增益修正。横扫打击需要一把中型或大型武器。当装备大型武器时，还会获得 +1 最小格档修正以及 +1 最大招架修正。</p></li>
</ul>

<p><strong>盾击(Shield Bash)</strong></p>

<p>副手盾牌攻击，将目标击退并在实际造成伤害后眩晕目标 D3 回合。盾击不会被格档、闪避或招架，它需要装备一把近战武器和一面盾牌。盾击还会将偏斜修正从最小格档修正改为格档修正。</p>

<p><strong>潜行(Silent Move)</strong></p>

<p>移动行动让生物在视野中隐秘。在隐秘状态下发动近战攻击将造成双倍伤害，且无法格档、闪避和招架。</p>

<p><strong>读写：常识(Literacy:Common)</strong></p>

<p>允许生物常规读写，释放记录在魔法卷轴上的法术，释放魔杖的能力。学习读写：天使，读写：龙系，读写：地狱 前必须先学习读写：常识。</p>

<ul>
<li><p><strong>读写：天使(Literacy:Celestial)</strong>
允许生物从魔法书中学习天使系（Celestial Spells）法术。</p></li>
<li><p><strong>读写：龙系(Literacy:Draconic)</strong>
允许生物从魔法书中学习龙系（Deaconic Spells）法术。</p></li>
<li><p><strong>读写：地狱(Literacy:Infernal)</strong>
允许生物从魔法书中学习地狱系（Infernal Speels）法术。</p></li>
</ul>

<p><strong>专注施法(Focused Cast)</strong></p>

<p>允许生物定位任何在视野直线可达区的目标并释放法术（通常法术只能定位邻接格的目标）。另外，直接伤害或治疗法术都会因每点对应的属性增益修正获得额外的 D3 点伤害或治疗效果，而不是常规的 1 点。</p>

<p><strong>沉默施法(Silent Cast)</strong></p>

<p>允许生物在沉默状态释放法术，且将失法的距离修正减半向下取整。沉默施法还会教会沉净施法 （Clearcasting） 。</p>

<p><strong>黑暗视觉(Dark Vision)</strong></p>

<p>增加一格视野，并将距离修正减半向下取整。</p>

<p><strong>双持(Dual Wield)</strong></p>

<p>副手攻击不再承受的命中修正的惩罚，伤害和招架修正取敏捷修正而不是其一半。</p>

<p><strong>锐利目光(Keen Eye)</strong></p>

<p>增加一格搜索半径，并在移动或休息行动时获得一次搜索周围的免费行动。锐利目光还会在失败的搜索检定后重掷。</p>

<p><strong>第六感(Sixth Sense)</strong></p>

<p>允许生物重掷反射检定，并在拾起装备或使用未鉴定的被诅咒物品前给出警告。</p>

<p><strong>坚强意志(Strong Will)</strong></p>

<p>允许生物重掷失败的精神检定，并将媚惑、忌妒、恐惧、狂暴、贪婪、欲望、鲁莽效果的持续时间减半，向下取整。</p>

<p><strong>陷阱大师(Trap Master)</strong></p>

<p>允许生物看见隐藏的捕熊夹，站在其上不会触发效果。陷阱大师还能拆解可见的捕熊夹留到以后使用。</p>

<p><strong>变形：狼(Shapeshift:Wolf)</strong></p>

<p>将生物变为一只狼，把装备的武器和天赋替换成下列：</p>

<ul>
<li>残忍撕咬 (Ferocious Bite) (D6, Melee/Medium/Crushing)</li>
<li>英勇冲锋 (Level 3)</li>
<li>潜行 (Level 6)</li>
<li>第六感 (Level 9)</li>
<li>锐利目光(Level 12)</li>
</ul>

<p><strong>变形：熊(Shapeshift:Bear)</strong></p>

<p>将生物变为一头熊，把装备的武器和天赋替换成下列：</p>

<ul>
<li>残忍撕咬 (Ferocious Bite) (D6, Melee/Medium/Crushing)</li>
<li>英勇冲锋 (Level 3)</li>
<li>粉碎打击 (Level 6)</li>
<li>坚强意志 (Level 9)</li>
<li>锐利目光(Level 12)</li>
</ul>

<p><strong>狂野怒火 (Bestial Wrath)</strong></p>

<p>在变形时增加 D3 物理伤害。这个天赋还会被下列遗产增强：Bestial Vigour ，Leader of the Pack 。</p>

<hr />

<h1>法术</h1>

<p>和其它大多数行动不同，法术可以使用精力和血来施放 。如果生物没有精力施法的话，可以献祭 D3 点血来施放。</p>

<p>施法通常需要通过两个独立的检定。第一个检定称为施法命中检定，用来决定法术是否命中想作用的目标（见战斗系统）。第二个检定根据法术的不同有很多名字，它用来决定法术是否附加一或多个随机效果。</p>

<p>施法命中检定使用施法者的耐力或魅力修正作为施法修正（攻击修正），用哪个取决于法术。</p>

<p>用来移除已有效果的法术使用施法增益修正来对抗需移除效果的强度等级修正，以下列公式来决定是否成功：</p>

<p>移除效果检定：2D6 + 施法修正 >= 7 + 强度等级修正</p>

<p>下列法术描述中用 X 指代耐力增益修正，Y 指代魅力增益修正，Z 指代 生物经验等级 / 4 。例如，如果一个效果的持续时间是 XD6 x 10 回合，而施法者的耐力增益修正是 3 ，则该效果可持续 3D6 x 10 回合。</p>

<p><strong>沉净施法 (Clearcasting)</strong></p>

<p>沉净施法是一个可学习的被动技能，它赋予施法者一次不消耗精力的施法机会。</p>

<p>专注施法检定：D6 + 暴击修正 >= 6</p>

<p>注意，当施法者没有精力或投出 1 时，检定都直接失败。</p>

<p><strong>天使法术（Celestial Spells）</strong></p>

<ul>
<li><p><strong>治疗疾病（Cure Disease）</strong>
尝试移除目标生物身上的一个疫病。治疗疾病使用魅力修正做法术命中检定。</p></li>
<li><p><strong>治疗中毒（Cure Poison）</strong>
尝试移除目标生物身上的一个中毒效果。治疗中毒使用魅力修正做法术命中检定。</p></li>
<li><p><strong>驱散魔法（Dispel Magic）</strong>
尝试移除目标生物身上，或特定地点，施法者物品栏中的物品上的一个魔法效果。驱散魔法 使用魅力修正做法术命中检定。</p></li>
<li><p><strong>神之恩典（Divine Grace）</strong>
赋予施法者和他视线内所有友方单位一个 (D6+Y) x 10 回合的持续效果，该效果增强敏捷、魅力各 1 点，物理抗性、毒药抗性、疾病抗性各 1 点。神之恩典使用魅力修正做法术命中检定。</p></li>
<li><p><strong>天赋神力（Divine Might）</strong>
赋予施法者和他视线内所有友方单位一个 (D6+X) x 10 回合的持续效果，该效果增强力量、耐力各 1 点，火焰抗性、冰霜抗性、震击抗性各 1 点。神之恩典使用耐力修正做法术命中检定。</p></li>
<li><p><strong>神圣领域（Divine Reach）</strong>
赋予施法者一个 (D6+X) x 10 回合的持续效果，允许他对视线内的任何目标施放法术。如果生物同时受神圣领域和专注施法天赋的影响，施法命中距离修正减半并向下取整。神圣领域使用耐力修正做法术命中检定。</p></li>
<li><p><strong>治疗之触（Healing Touch）</strong>
治疗目标生物及 D6 + Y 点伤害，并尝试回复一点属性伤害。治疗之触使用魅力修正做法术命中检定。</p></li>
<li><p><strong>治疗光波（Healing Wave）</strong>
治疗目标生物及所有和该目标邻接的生物 D3 + Y 点伤害。治疗光波使用魅力修正做法术命中检定。</p></li>
<li><p><strong>回复之触（Renewing Touch）</strong>
赋予目标生物一个 D6+Y 回合的持续效果，每个回合治疗 D3 + Y 点。回复之触使用魅力修正做法术命中检定。注意，该持续效果在受到伤害（且伤害高于施法者魅力修正）时，减少到施法者魅力修正值。</p></li>
<li><p><strong>超度亡魂（Turn Undead）</strong>
对目标不死生物造成 D6 + Y 点魔法伤害。超度亡魂有一定机会立刻杀死不死生物。这个机会是 2D6 + Y >= 10 + Z 。超度亡魂使用魅力修正做法术命中检定，视为一个法术球，但不能被增大。</p></li>
</ul>

<p><strong>龙系法术（Draconic Spells）</strong></p>

<ul>
<li><p><strong>魔法增效（Amplify Magic）</strong>
赋予施法者一个 (D6+X) x 10 回合的持续效果，增强法术球的伤害 D6 。魔法增效使用耐力修正做法术命中检定。</p></li>
<li><p><strong>电球术（Electric Orb）</strong>
对目标生物造成 D6 + X 点震击伤害。电球有一定机会使目标休克 X / 2 回合。这个机会有 2D6 + X >= 10 + 震击抗性。电球术使用耐力修正做法术命中检定。</p></li>
<li><p><strong>法术球增大（Enlarge Orb）</strong>
赋予施法者一个 2D6+X 回合的持续效果，该效果可让下一发法术球爆炸造成额外 D6 + X 点伤害，并对目标邻接的生物造成法术原本的伤害。法术球增大使用耐力修正做法术命中检定。</p></li>
<li><p><strong>火球术（Flaming Orb）</strong>
对目标生物造成 D6 + X 点火焰伤害。火球有一定机会给目标附加 D6 + X 回合的燃烧效果，每回合会造成 D3 点火焰伤害。这个机会有 2D6 + X >= 10 + 火焰抗性。火球术使用耐力修正做法术命中检定。</p></li>
<li><p><strong>冰球术（Frozen Orb）</strong>
对目标生物造成 D6 + X 点冰霜伤害。冰球有一定机减慢目标 D6 + X 回合.这个机会有 2D6 + X >= 10 + 冰霜抗性。冰球术使用耐力修正做法术命中检定。</p></li>
<li><p><strong>照明术（Illumination）</strong>
赋予施法者和他视线内所有友方单位一个 (D6+Y) x 10 回合的持续效果，增加他们的视野范围及搜索范围 1 格。照明术使用魅力修正做法术命中检定。</p></li>
<li><p><strong>魔法盔甲（Mage Armour）</strong>
赋予施法者一个 (D6+X) x 10 回合的持续效果，增强所有的抗性。增强值为 X / 2 或 1 里较高的一个。当施法者装备的物品因任何理由发生变化时，该效果自动解除。魔法盔甲使用耐力修正做法术命中检定。</p></li>
<li><p><strong>镜像术（Mirror Image）</strong>
复制一个施法者持续 (D6 + Y) x 10 回合，该复制体看起来会发动和施法者相同的行动。复制体收到的任何伤害都会减少持续时间的 (伤害)D6 个回合。镜像术使用魅力修正做法术命中检定。</p></li>
<li><p><strong>移除诅咒（Remove Curse）</strong>
尝试移除目标生物身上，或特定地点，施法者物品栏中的物品上的一个诅咒效果。移除诅咒使用魅力修正做法术命中检定。</p></li>
<li><p><strong>念动力（Telekinesis）</strong>
允许施法者使用魔法来操纵远程物体，像门、宝箱、开关等这类东西。念动力使用耐力修正做法术命中检定。</p></li>
</ul>

<p><strong>地狱法术（Infernal Spells）</strong></p>

<ul>
<li><p><strong>放逐恶魔（Banish Daemon）</strong>
对目标恶魔造成 D6 + Y 点魔法伤害。放逐恶魔有一定几率立刻杀死恶魔。这个几率是 2D6 + X >= 10 + Z 。放逐恶魔使用耐力修正做法术命中检定，视为一个法术球，但不能被增大。</p></li>
<li><p><strong>降咒术（Bestow Curse）</strong>
尝试给目标生物施加一个随机的持续 (D6 + X) x 10 回合的诅咒效果。几率为 2D6 + X >= 7 + Z 。降咒术使用耐力修正做法术命中检定。如果检定失败，则改为释放 Curse of Agony 。</p></li>
<li><p><strong>灵魂捕捉（Capture Soul）</strong>
尝试给目标生物附加一个持续 D6 + X 回合的持续效果，若目标生物死亡，该生物的灵魂将被捕获进一颗晶石中。当 X 不大于 0 时，该法术无效。灵魂捕捉使用耐力修正做法术命中检定。</p></li>
<li><p><strong>魔鬼面容（Demonic Visage）</strong>
赋予施法者一个 (D6+Y) x 10 回合的持续效果，任何试图攻击他的生物都必须先通过一次精神检定，失败后会造成 D3 回合的恐惧。受到任何伤害都会使得魔怪面容的持续时间减少 (伤害)D6 回合。魔鬼面容使用魅力修正做法术命中检定。</p></li>
<li><p><strong>奴役恶魔（Enslave Daemon）</strong>
尝试魅惑一个恶魔 (D6 + Y) x 10 回合。几率为 2D6 + Y >= 8 + Z 。奴役恶魔使用魅力修正做法术命中检定。</p></li>
<li><p><strong>位面传送（Plane Shift）</strong>
将施法者立即传送到视野内的另一个位置。位面传送使用耐力修正做法术命中检定。</p></li>
<li><p><strong>释放灵魂（Release Soul）</strong>
从施法者的物品栏中随机选取一颗魂晶，释放其中的灵魂。释放的灵魂可以用于对目标生物造成 2D6 + X 点魔法伤害，也可以用于给物品栏中的一个装备做一次随机强化。如果强化失败，将对施法者造成 2D6 + X 点魔法伤害。释放灵魂使用耐力修正做法术命中检定。</p></li>
<li><p><strong>召唤恶魔（Summon Daemon）</strong>
尝试召唤一个恶魔并奴役它（见奴役恶魔）。召唤恶魔使用魅力修正做法术命中检定。</p></li>
<li><p><strong>毒球术（Venomous Orb）</strong>
对目标生物造成 D6 + X 点毒药伤害。毒球术另外有一次机会附加一个持续 (D6 + X) x 10 回合的随机中毒效果。这个几率为 2D6 + X >= 10 + 毒药抗性。毒球术使用耐力修正做法术命中检定。</p></li>
<li><p><strong>病球术（Virulent Orb）</strong>
对目标生物造成 D6 + X 点疾病伤害。病球术另外有一次机会附加一个持续 (D6 + X) x 10 回合的随机疾病效果。这个几率为 2D6 + X >= 10 + 疾病抗性。病球术使用耐力修正做法术命中检定。</p></li>
</ul>

<hr />

<h1>诅咒（Curse）</h1>

<p>被诅咒后，每个回合都有 1/36 (2D6 投出 2) 的机会效果生效。如果诅咒是由法术造成的，那么这个几率会随施法者的耐力修正而上升。如果诅咒来源于其它地方，则根据来源的强度等级调高几率。</p>

<p>效果是否生效是用修正值加 2 和投骰的值相比较来决定。如果投出值小于等于比较值，效果生效。</p>

<p>例如：如果一个生物被下了强度等级 2 的诅咒，那么在诅咒持续时间内每个回合都会因为 2D6 投出 2,3,4 而效果生效。</p>

<p>在下列描述中，使用 X 代替强度等级。例如，如果描述中说一个效果持续 XD6 x 10 回合，而效果强度等级为 3 的话，该效果持续 3D6 x 10 回合。</p>

<p><strong>痛苦诅咒（Curse of Agony）</strong>
有机会导致 D3 + X 魔法伤害的持续效果。</p>

<p><strong>忌妒诅咒（Curse of Envy）</strong>
有机会使生物陷入 D6 回合忌妒状态的持续效果。忌妒状态的生物将被强制向最近的同性别生物移动并攻击。如果没有这样的生物则失去回合。</p>

<p><strong>贪食诅咒（Curse of Gluttony）</strong>
有机会使生物花一个回合吃喝的持续效果。如果生物没有可食用的东西，则狂暴 D6 回合。</p>

<p><strong>贪婪诅咒（Curse of Greed）</strong>
有机会使生物陷入 D6 回合贪婪状态的持续效果。陷入贪婪状态的生物被强制向最近的物品移动并尝试捡起来。如果没有物品则失去回合。</p>

<p><strong>饥饿诅咒（Curse of Hunger）</strong>
有机会使生物在七级饥饿条（Famished, Starving, Hungry, Not Hungry, Satiated, Bloated, Choking）上失去一个等级。这个效果仅在扔出骰未修正的情况下为 2 才发生。别的诅咒成功的情况会减少饥饿值 (4+X)D6 。</p>

<p><strong>淫欲诅咒（Curse of Lust）</strong>
有机会使生物陷入D6 回合淫欲状态的持续效果。淫欲状态的生物将被强制向最近的异性移动并打的对方屈服，如果没有合适的生物则失去回合。</p>

<p><strong>傲慢诅咒（Curse of Pride）</strong>
有机会使生物陷入 D6 回合傲慢状态的持续效果。傲慢状态的生物将强制向最近的敌人移动并攻击，如果没有敌人则失去回合。</p>

<p><strong>懒惰诅咒（Curse of Sloth）</strong>
有机会使生物失去一点精力，并失去下个回合。该效果还会重扔成功的精力回复骰。</p>

<p><strong>干渴诅咒（Curse of Thirst）</strong>
有机会使生物在七级干渴条（Parched, Dehydrated, Thirsty, Not Thirsty, Satiated, Hydrated, Drenched）上失去一个等级。这个效果仅在扔出骰未修正的情况下为 2 才发生。别的诅咒成功的情况会减少干渴值 (4+X)D6 。</p>

<p><strong>愤怒诅咒（Curse of Wrath）</strong>
有机会使生物陷入 D6 回合的狂暴状态。狂暴生物强制向最近的生物移动并攻击，如果不存在生物则失去回合。</p>

<hr />

<h1>毒药（Poison）</h1>

<p>中毒后，每个回合都有 1/36 (2D6 投出 2) 的机会效果生效。如果中毒是由法术造成的，那么这个几率会随施法者的耐力修正而上升。如果中毒来源于其它地方，则根据来源的强度等级调高几率。</p>

<p>效果是否生效是用修正值或效力加 2 和投骰的值相比较来决定。如果投出值小于等于比较值，效果生效。</p>

<p>例如：如果一个生物被下了强度等级 2 的毒药，那么在中毒持续时间内每个回合都会因为 2D6 投出 2,3,4 而效果生效。</p>

<p><strong>致盲之毒（Blinding Poison）</strong>
有机会使生物持续 D6 回合盲眼的持续效果。盲眼的生物除了什么都看不见外，和平常一样。致盲之毒同时还会根据毒药强度给命中骰附加一个负修正。</p>

<p><strong>魅惑之毒（Charming Poison）</strong>
有机会使生物持续 D6 回合陷入魅惑状态的持续效果。被魅惑的生物被强制攻击施展魅惑者的敌人中最近的那个。如果不存在敌人则失去回合。魅惑之毒同时还会让生物攻击施展魅惑者前先要通过一次精神检定。</p>

<p><strong>混乱之毒（Confusing Poison）</strong>
有机会使生物持续 D6 回合混乱的持续效果。混乱生物向随机方向移动攻击。换乱之毒同时还会根据毒药强度给命中骰附加一个负修正。</p>

<p><strong>死亡之毒（Deadly Poison）</strong>
有机会对生物造成 D3 + X 点毒伤害的持续效果。死亡之毒同时还会重投成功的回血骰。</p>

<p><strong>震聋之毒（Deafening Poison）</strong>
有机会使生物持续 D6 回合耳聋的持续效果。震聋只毒同时还会根据毒药强度给施法骰附加一个负修正。对有沉默施法天赋的生物无效。</p>

<p><strong>枯竭之毒（Draining Poison）</strong>
有机会让生物失去一点精力的持续效果。枯竭之毒同时还会根据毒药强度给精力回复骰附加一个负修正。从免疫角度上看，这个毒药的伤害被视为精力吸收。</p>

<p><strong>吸血之毒（Leeching Poison）</strong>
有机会对生物失去 D3 + X 点血。吸血之毒同时还会根据毒药强度给回血骰附加一个负修正。从免疫角度上看，这个毒药的伤害被视为吸血。</p>

<p><strong>麻痹之毒（Paralytic Poison）</strong>
有机会麻痹生物 D6 回合的持续效果。麻痹之毒被看作生物身上的一个迟缓效果。</p>

<p><strong>沉默之毒（Silencing Poison）</strong>
有机会沉默生物 D6 回合的持续效果。被沉默的生物不能释放法术，阅读卷轴以及和别的生物对话。沉默之毒同时还会根据毒药强度给施法骰附加一个负修正。对有沉默失法天赋的生物无效。</p>

<p><strong>沉睡之毒（Sleeping Poison）</strong>
有机会让生物沉睡 D6 回合的持续效果。任何伤害都会打断睡眠效果，但只要还在中毒，就有可能下个回合再次让生物睡去。</p>

<p><strong>迟缓之毒（Slowing Poison）</strong>
视为一个持续的迟缓效果，并有持续可能让生物失去下个回合。迟缓之毒还会根据毒药强度来降低闪避、招架以及格档修正。但这个效果不能把各自修正降低到固有最小等级之下（例如装备了圆盾后至少有 +1 格档修正）。</p>

<hr />

<h1>疾病（Diseases）</h1>

<p>疾病在每个回合都有 1/36 (2D6 投出 2) 的机会效果生效。如果疾病是由法术造成的，那么这个几率会随施法者的耐力修正而上升。如果疾病来源于其它地方，则根据来源的强度等级调高几率。</p>

<p>效果是否生效是用修正值或效力加 2 和投骰的值相比较来决定。如果投出值小于等于比较值，效果生效。</p>

<p>例如：如果一个生物被下了强度等级 2 的疾病，那么在中毒持续时间内每个回合都会因为 2D6 投出 2,3,4 而效果生效。</p>

<p><strong>肌肉疼痛（Aching Muscle）</strong>
可能造成 1 点力量损伤的持续效果，并有机会对生物造成 D6 回合的迟缓效果。</p>

<p><strong>血瘟（Bloody Flux）</strong>
可能造成 1 点耐力损伤的持续效果，并有机会对生物造成 D3 + X 的伤害。</p>

<p><strong>骨病（Bone Plague）</strong>
可能造成 1 点力量损伤的持续效果，并有机会对生物造成 D6 回合的麻痹效果。</p>

<p><strong>肺病（Burning Lung）</strong>
可能造成 1 点耐力损伤的持续效果，并有机会对生物造成 D3 点的精力伤害。</p>

<p><strong>地城热（Dungeon Fever）</strong>
可能触发其它疾病效果的持续效果。</p>

<p><strong>下体瘙痒（Itching Groin）</strong>
可能造成 1 点敏捷损伤的持续效果，并有机会对生物造成 D6 回合的盲眼。</p>

<p><strong>腐烂气息（Putrid Breath）</strong>
可能造成 1 点魅力损伤的持续效果，并有机会对生物造成 D6 回合的沉默。</p>

<p><strong>关节肿胀（Swollen Joint）</strong>
可能造成 1 点敏捷损伤的持续效果，并有机会对生物造成 D6 回合的混乱。</p>

<p><strong>肌肉腐烂（Rotting Flesh）</strong>
可能造成 1 点魅力损伤的持续效果，并有机会对生物造成 D6 回合的沉睡。</p>
]]>
    </content>
</entry>
<entry>
    <title>RPC 之恶</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2015/11/rpc.html" />
    <id>tag:blog.codingnow.com,2015://1.986</id>
    
    <published>2015-11-30T06:36:37Z</published>
    <updated>2015-12-04T16:07:00Z</updated>
    
    <summary>起因是最近有人在 skynet 邮件列表里贴了段错误 log ，从 log 显示，他在 table.sort 的比较函数里调用了 skynet 的 snax rpc 去获取远程数据。然后被 lua 无情的报了 attempt to yield across a C-call boundary 。 就 table.sort 不能 yieldable 的问题，其实在 lua 邮件列表里讨论过 。老大的说法是，这个 C 实现是递归的，想要在 C 层面保留上下文非常困难，如果勉强实现，也会大大降低正常不需要 yield 的 case 的性能，非常不划算。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="skynet" />
            <category term="语言与设计" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>起因是最近有人在 skynet 邮件列表里贴了段错误 log ，从 log 显示，他在 table.sort 的比较函数里调用了 skynet 的 snax rpc 去获取远程数据。然后被 lua 无情的报了 attempt to yield across a C-call boundary 。</p>

<p>就 table.sort 不能 yieldable 的问题，其实<a href="http://lua-users.org/lists/lua-l/2015-02/msg00272.html">在 lua 邮件列表里讨论过</a> 。老大的说法是，这个 C 实现是递归的，想要在 C 层面保留上下文非常困难，如果勉强实现，也会大大降低正常不需要 yield 的 case 的性能，非常不划算。</p>

<p>通过这件事，我反而觉得 none-yieldable 的限制反而提前阻止了一个错误的实现，其实是应该庆幸的。</p>
]]>
        <![CDATA[<p>最容易发现的是性能问题。</p>

<p>在《Unix 编程艺术》一书 7.3.2 节讨论 RPC 时，这样批评道：</p>

<p>“ a. 无法准确预估出一个指定调用会涉及多少数据的列集和散集，b. RPC 模型往往鼓励程序员把网络交易视为无成本行为。即使在某个事务处理接口上只额外增加一个来回，往往也增加足够多的网络延迟，完全抵消了解析或列集的开销。”</p>

<p>这段话的语境是把 RPC 和传统的消息通讯方式相比较，针对那些认为 RPC 的效率更高的观点说的。</p>

<p>即使不看效率，单看 RPC 给编程实现带来的方便性，其实最终是增加了，而不是减少了系统的复杂度。原文引用：</p>

<p>“支持 RPC 的主要理由同时恰恰证明了 RPC 增加了，而不是降低了程序的全局复杂度。”……(那些基于 RPC 的框架) “随着人们使用经验的增长，都已经从 Unix 世界的视野中消失了。这完全可能是因为这些方法能够解决的问题还不如它们引发的问题多。”</p>

<p>关于 RPC 的批评，还可以看这篇 paper <a href="http://www.cs.vu.nl/~ast/afscheid/publications/euteco-1988.pdf">A Critique of the Remote Procedure Call Paradigm</a></p>

<hr />

<p>snax 是对 skynet api 做的一个 rpc 封装，原意是让使用的人门槛更低。但做完我就后悔了，rpc 只是表面上简单而已，但我自己却直觉的排斥这种做法，所以也没有把它作为 skynet 其它基础组件的基础。当用户开始以 RPC 方式调用时，他真的有一种不就是调了个函数的错觉。</p>

<p>针对 table.sort 这个比较函数里做 RPC 调用这件事说，对 n 个数据排序，table.sort 使用的是传统的快速排序，一种内部排序算法。它注重的是减少比较次数，而视获得数据的成本为 0 。在排序过程中，每个元素都不只一次的取出来比较。而 RPC 获取元素的成本显然是很高的，所以初看来，这里造成了严重的性能问题。</p>

<p>但如果仅仅是性能问题倒还好，可这样做其实正确性也无法保证。</p>

<p>如果要排序的元素在远程，也就是在另一个地方变化（如果是不变量也不必储远程获取了）。那么显然排序过程中，这些量是易变的，也就是你多次取同一个元素是可能不一样的。这样，sort 算法无法避免出现 a > b , b > c , 而 c > a 的情况出现。排序算法是无法正常工作的。</p>

<hr />

<p>用一个通俗点的例子：如果你想按全国所有中学的学生人数对学校做一个排序。你是先把所有学校的人数都做一个调研，记在一起再排序；还是对这些信息一无所知的情况下，先按排序算法流程走，算法要求比较某两个学校人数的时候，再去调查这两个学校的数据？</p>
]]>
    </content>
</entry>
<entry>
    <title>skynet 中实现一个 crontab 的方法</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2015/11/skynet_crontab.html" />
    <id>tag:blog.codingnow.com,2015://1.985</id>
    
    <published>2015-11-16T13:37:59Z</published>
    <updated>2015-11-18T02:33:29Z</updated>
    
    <summary>很多人问起，为什么 skynet 的时钟不随系统时钟变更。我的答案是，skynet 系统保证内部的计时机构是单调递增的，有了这个约束，用起来可以回避很多问题。 那么怎么做一个定时任务，好像 crontab 那样，而且可以随系统时间调整而变化。我的答案是，这是个纯业务层的需求，你爱怎么做怎么做，根据你的需求（业务量多少，定时是否频繁等）可以有不同的实现方式。但是总而言之，你需要在 skynet 里定制一个服务，可以按时驱动某种消息。而这个服务的定时机构，不应该完全依赖于 skynet 自己的内部时钟。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="skynet" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>很多人问起，为什么 skynet 的时钟不随系统时钟变更。我的答案是，skynet 系统保证内部的计时机构是单调递增的，有了这个约束，用起来可以回避很多问题。</p>

<p>那么怎么做一个定时任务，好像 crontab 那样，而且可以随系统时间调整而变化。我的答案是，这是个纯业务层的需求，你爱怎么做怎么做，根据你的需求（业务量多少，定时是否频繁等）可以有不同的实现方式。但是总而言之，你需要在 skynet 里定制一个服务，可以按时驱动某种消息。而这个服务的定时机构，不应该完全依赖于 skynet 自己的内部时钟。</p>
]]>
        <![CDATA[<p>如果你的任务并不多，我可以描述一个最简单的实现方法：</p>

<p>在这个服务中，可以维系一张无序表，里面放着未来什么时候将触发什么任务。这些任务是其它位置注册过来的，任务只需要是一个独立的字符串即可，也可以是一个任务名带一个时间，比如 “9 点领奖” 这样。到点可以把这个串发送给订阅者。</p>

<p>串中带上时间的好处是，万一哪个环节出了问题，订阅方可以自己去重，丢弃那些已经做过的任务。</p>

<p>这样使用的流程就是，任务管理器向此服务注册一系列任务，约定每个任务的串。任务执行者去这个服务订阅对应的串，一旦到时间，就会获得通知。</p>

<p>这个服务可以使用一个 skynet 内置的 timeout 回调来触发任务。每个注册的新任务都比较一下历史所有任务，如果时间更进则注册一个新的 skynet.timeout 回调。而每次收到 skynet.timeout 提醒时，都检查一下最近的那个任务是否可以通知出去，如果发送完通知，则在剩下的任务中查找最近的一个。</p>

<p>这个算法有 O(n)  的复杂度，但实现会常简单。鉴于 n 通常都不大，我们用简单的方法就够了。</p>

<p>该服务还可以支持和系统时间同步。skynet 目前的机制是 skynet.now() 返回的是进程启动的时长，而 skynet.starttime()  返回的是进程启动的 UTC 时间。如果支持和系统时间同步，或是直接设置一个虚拟的时间，我们就只是修正一下内部记录的时间基点而已。服务的通知机制则和内部时间基点加起来做任务时间就可以了。</p>

<p>另外，还可以支持从外部（比如监听一个 socket 端口，或是 http 端口）直接发布一个任务，而不需要自己等待时钟。这样，你完全可以在外部系统的 crontab 中写好定时触发的任务，用命令行向 skynet 进程发布。</p>

<p>有了外部驱动的能力，你就不需要自己再重新发明轮子，再造一个 crontab 了。要知道实现一整套 crontab 兼容的 DSL 还是有一些工作量的。</p>

<hr />

<p><del>最后，请警惕的是，如果你的 skynet 进程需要开上几周甚至几个月。skynet.now() 长期看是不可靠的。因为硬件时钟本身就不会特别准，系统为了保持一个长期稳定的时间，也是靠定期去网络对时实现的。而 skynet 进程一旦启动，就没有机会对时了。所以，如果你的进程需要工作很长时间的话，不要直接依赖 skynet.now() 来做长周期的定时任务。尤其在多台机器组成集群的架构下，还有可能多台机器长期工作时钟快慢不一致。</del></p>

<p>参考: <a href="http://askubuntu.com/questions/138916/why-is-ubuntus-clock-getting-slower-or-faster">Why is Ubuntu's clock getting slower or faster?</a></p>

<p>11 月 18 日 补:</p>

<p>之前 skynet 使用了 <code>CLOCK_MONOTONIC_RAW</code> 不会被 ntp 调整时钟频率影响，所以会导致长时间运行和真实时间不一致。其实改成 <code>CLOCK_MONOTONIC</code> 就好了。即可以保证时间连续性，又可以由 ntp 校对时间。</p>

<p>修改之后，就不会再有这个问题。</p>
]]>
    </content>
</entry>
<entry>
    <title>闲扯几句移动社交软件</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2015/11/chat_app.html" />
    <id>tag:blog.codingnow.com,2015://1.984</id>
    
    <published>2015-11-15T11:14:56Z</published>
    <updated>2015-11-15T11:59:38Z</updated>
    
    <summary>我不用微信, 不过见过大概是什么样子。以前用过 icq/qq/gtalk ，现在也用的少了。目前流行的社交平台，也就是微博和 twitter 用一下吧。今天有些想法，闲扯几句。 我觉得，作为现在安装在手机上为主的社交用软件，主要应帮人解决的基本社交需求是： 给特定的人发特定的消息，或两人间讨论问题。这一点，以前手机短信就可以作到，只不过现代软件更可以发语音、视频、图片、地理位置等等，完善了这个用途。在现代软件普及之前，email 是一个对短信非常好的补充，可惜还不够普及。 建立新的社交关系。可以是社交场合找到陌生人，也可以是由熟人引见新朋友，还可以是自我推销。在过去只用手机做主要联系方式的时代，很多人利用名片完成这一点。也可以是向人打听手机号码。然后把新社交关系延伸到 1 里。 就某些话题在半公开场合一群人聚在一起扯淡。过去的网络论坛，后来的 qq 群，微博、微信，都满足了这个需求。这里提一下微博和 twitter 的主要区别之一，就是微博可以在一个主信息下，一堆人围绕着 po 主进行扯淡，这种信息组织方式和 twitter 很为不同。一开始我总觉得这种设计有些问题，但一直没想太清楚。 个人对外发布信息。一部分信息会引导为 3 ，另一部分仅仅是发布而已。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="杂记" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>我不用微信, 不过见过大概是什么样子。以前用过 icq/qq/gtalk ，现在也用的少了。目前流行的社交平台，也就是微博和 twitter 用一下吧。今天有些想法，闲扯几句。</p>

<p>我觉得，作为现在安装在手机上为主的社交用软件，主要应帮人解决的基本社交需求是：</p>

<ol>
<li><p>给特定的人发特定的消息，或两人间讨论问题。这一点，以前手机短信就可以作到，只不过现代软件更可以发语音、视频、图片、地理位置等等，完善了这个用途。在现代软件普及之前，email 是一个对短信非常好的补充，可惜还不够普及。</p></li>
<li><p>建立新的社交关系。可以是社交场合找到陌生人，也可以是由熟人引见新朋友，还可以是自我推销。在过去只用手机做主要联系方式的时代，很多人利用名片完成这一点。也可以是向人打听手机号码。然后把新社交关系延伸到 1 里。</p></li>
<li><p>就某些话题在半公开场合一群人聚在一起扯淡。过去的网络论坛，后来的 qq 群，微博、微信，都满足了这个需求。这里提一下微博和 twitter 的主要区别之一，就是微博可以在一个主信息下，一堆人围绕着 po 主进行扯淡，这种信息组织方式和 twitter 很为不同。一开始我总觉得这种设计有些问题，但一直没想太清楚。</p></li>
<li><p>个人对外发布信息。一部分信息会引导为 3 ，另一部分仅仅是发布而已。</p></li>
</ol>
]]>
        <![CDATA[<p>就需求 1 来说，点对点消息在通讯比例中应该是越来越少的，但却必不可少。我认为微信在这方面是走了回头路。</p>

<p>其实过去手机短信就已经足够好了，你只要知道对方的号码，无论对方是否确认，都可以发送信息。email ，twitter, 微博皆是如此。这才是最自然的需求。而微信和 qq 一样，都必须先建立其相互确认的好友关系才行（公众号的问题后面再谈）。</p>

<p>确认无非是为了减少垃圾信息的干扰，但今天，手机短信，email 的垃圾信息骚扰的根本并不在于无法过滤，而是其开放造成的。如果是腾讯这种封闭平台，很容易过滤掉垃圾信息才对。email 和短信的第 2 个问题是，如果你收到一个陌生人发来的信息，对方可能知道你是谁，而你不知道他是谁。而这个，完全可以通过账户的自我介绍，以及社会中的多数人给账号贴的公开标签来完成。这个标签当然也包括类似，垃圾信息制造者（广告）等，帮助接收者过滤信息。</p>

<p>我想一个更好的做法应该是，无论谁，只要和你建立了某种联系，并不需要通过你的确认就可以给你发送信息。这并不应该加了双向关系确认后才可以。而对于垃圾信息，应该有一种合理的举报和过滤（黑名单）机制来减少对人的干扰。</p>

<p>所以我们并不需要刻意的去维护一个好友/联系人名单。系统自然可以根据信息来往和社交关系分析，排列出和你关系密切的人，自然形成一个名单。我们在自己的设备/账号中，只需要保留少量关系密切的人的联系入口，等需要的时候，可以根据名字或标签，在自己的社交历史中搜索直接或间接的关联人就够了。</p>

<p>而在收到陌生消息后，我可以查看这个人是谁，以及他是如何关联到我的。对于亲密关系的人，消息应该排在优先位置。而当我被信息轰炸时，一些不紧要的消息会被系统暂时藏起来，在大量重要信息处理完后，才显示给我看。只有双方来回交流后，系统才自动给联系人升级，而不是依赖用户自己去给对方提权。</p>

<p>所以，联系人名单是系统动态维护的。暗含着权值，却不用告之用户。他到底是在某次聚会中当面互扫 QR 码认识的？还是被我的熟人引见的？还是通过六度关系搜索来的？在对方资料中都可以从系统查到。</p>

<p>这样便可以让用户放下维护联系人名单的心理负担了。</p>

<hr />

<p>关于 qq 群，我一直觉得是信息骚扰超过了它的实用价值。就是一群人聚在一起扯淡嘛，这个当然需要。但是我们是不是应该关注一下更本质的东西。怎么对系统分类，并协助用户过滤。</p>

<p>所以我觉得扯淡还是需要一个话题开始，以这个话题为结束。微博、微信朋友圈大约都是这个意思。但我觉得远不够。一群人扯淡并总不需要围绕同一个话题，也不需要一个严格的管理者和发起者。仅仅只是一帮人可以在一起扯，随时都有人退出和加入。发起话题和召集这群人的人并不是什么特权用户。</p>

<p>我把它看成是一个临时的，有主题的聊天室或论坛帖。任何人都可以发起，然后围绕这个人的紧密关系圈拓展开，变成多人扯淡的线索。和微博一样，如果你关注，那么你才打开看，并考虑参与。系统要做的是把你可能关注的信息推送给你，然后再由你决定是否参与。</p>

<p>作为潜在话题关注者，我关心的是主题是什么，以及哪些我熟悉的人参与的，或是有没有人提到我。</p>

<p>由于在扯淡中歪楼是必然的，所以应该有一个功能就是歪楼，开启一个新线索。但人群还是这些人群，所有参与老话题的人，包括发言的，和一直关注的（每次有新信息都展开开），都会收到新话题（歪楼）开启的信息，但是否跟进就是他自己的选择了。</p>

<p>说到底，就是以话题为核心的一个网状结构。我们从任何一个扯淡聚集区，通过里面的线索跳跃到新的线索上，每个线索中都有一群人。关系近的线索，人群结构也比较接近，但没有明确的发起人和组织人。也没有固定的群组。</p>

<hr />

<p>大概就是这些。胡思乱想而已。</p>
]]>
    </content>
</entry>
<entry>
    <title>终于升级了 linode  上的 ubuntu </title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2015/11/linode_ubuntu_upgrade.html" />
    <id>tag:blog.codingnow.com,2015://1.983</id>
    
    <published>2015-11-03T14:50:29Z</published>
    <updated>2015-11-03T15:13:44Z</updated>
    
    <summary>我部署在 linode 上的这个 blog 是 09 年装的 ubuntu 系统。只在 10 年的时候升级到 ubuntu 的 10.04 LTS 版，后来就一直懒得升。 其实敲一行指令就可以了，可每次 ssh 上去就是懒得做。今天突然觉得不太妥了，试了一下 do-release-upgrade 居然失败了 :( 。google 了一下，大约是说我这个系统停止维护太久了，早就超过了最后期限，升不了了。 痛定思痛，打算亡羊补牢一把。我想了一下，其实最主要的业务就是一个为 codingnow.com 解析域名的 bind9 服务，一个 apache 一个 mysql ，重装一下系统的话，把数据链过来应该问题不大。正好 linode 前些年送了我 8G 硬盘空间，一直懒的用上，正好装新系统。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="我爱折腾" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>我部署在 <a href="http://blog.codingnow.com/2014/06/linode1024.html">linode</a> 上的这个 blog 是 09 年装的 ubuntu 系统。只在 10 年的时候升级到 ubuntu 的 10.04 LTS 版，后来就一直懒得升。</p>

<p>其实敲一行指令就可以了，可每次 ssh 上去就是懒得做。今天突然觉得不太妥了，试了一下 do-release-upgrade 居然失败了 :( 。google 了一下，大约是说我这个系统停止维护太久了，早就超过了最后期限，升不了了。</p>

<p>痛定思痛，打算亡羊补牢一把。我想了一下，其实最主要的业务就是一个为 codingnow.com 解析域名的 bind9 服务，一个 apache 一个 mysql ，重装一下系统的话，把数据链过来应该问题不大。正好 linode 前些年送了我 8G 硬盘空间，一直懒的用上，正好装新系统。</p>
]]>
        <![CDATA[<p>工作进行的比预想的要麻烦的多，这提醒了我，下次一定要及时升级系统，不能再这么折腾了。</p>

<p>在新分区上安装 ubuntu 14.04 LTS 倒是很简单，linode 后台一分钟搞定，重新 reboot 就可以切到新系统。然后挂接老分区当数据盘用。我必须把 /home 和 /var 目录指回老的数据盘，否则新分区空间太少了。这个工作倒容易，只是一开始忘记修改 fstab ，导致系统重启后跑不起来（/var 目录被我做了个软连接到未挂接的分区上，导致 log 文件创建失败）。</p>

<p>最先折腾 bind9 服务，发现直接复制数据盘上的 etc 配置目录是不行的，有几个新安装产生的 key 文件要保留，失败过一次后，马上修好了。随便清理了一些配置文件里的垃圾。</p>

<p>然后 mysql 安装后发现指向数据盘上的库启动失败了 :( 检查 log 发现是我 10 年前创建的库太老了，mysql 5.5 居然读不进来。只好重启回老系统，把数据库直接 dump 成文本，然后再在新系统里导入。这中间忘记了 mysql 的 root 密码，修改了 mysql 的配置关掉密码，进入重置了一下。另外 blog 等几个系统用到的库的密码也忘记了，分别在配置文件中找了回来。</p>

<p>apache 重新安装折腾的时间最长，现在默认装的是 2.4 版， 和我之前的版本居然配置文件中有些命令有差别，老是报访问权限不对，各种淡疼。google 了老半天，然后批量替换了配置文件中的旧写法。</p>

<p>折腾过程中发现 apache2 的 error log 特别巨大，居然有 7G 之多。原来是我一些不太用到的 php 编写的页面实在是太老了，和 php5 最新版本（早两年升级过一次）各种不兼容，报了海量的废弃警告。加上老有发垃圾信息的爬虫每天来尝试，导致 log 增长的飞快。耐着性子把各种不兼容的地方改了过来，总算清静了。</p>

<hr />

<p>顺便我还研究了一下，为什么 blog 的留言现在这么慢，每次留言都要等 4,5 秒。打开 mysql  的慢查询记录，没有发现什么异常，留言过程中 top 也没看到 cpu 有什么暴涨。想来是卡在某种 IO 操作上了。最后发现是 blog 留言的后台用了一个 10  年前的反垃圾模块，会对外提交一个请求。估计最近两年那边不维护了，结果每次留言都卡在这个请求上好久。赶紧关掉这个没用的反垃圾插件，立刻流畅了。</p>

<p>就这样，我这个 blog 系统还能破罐子破摔坚持用几年吧，等哪天心情好了再重新搭一下。</p>

<p>可能各位同学在访问本网站时还会碰到一些奇怪的现象，那都是我维修工作没做到位，遇到的话可以留言或 email 告诉我一下 :) </p>
]]>
    </content>
</entry>
<entry>
    <title>扩展 lua require 的行为</title>
    <link rel="alternate" type="text/html" href="http://blog.codingnow.com/2015/10/lua_require_env.html" />
    <id>tag:blog.codingnow.com,2015://1.982</id>
    
    <published>2015-10-26T12:45:51Z</published>
    <updated>2015-10-26T05:14:10Z</updated>
    
    <summary>今天同事提了个需求，他希望可以给部分 lua 代码（由策划编写）做一个沙盒关起来。在 lua 里做沙盒很容易，只需要控制函数的环境就可以了。不过另一个附加需求是，这些代码还可以直接利用 require 加载。 而我们又不想去修改系统的 api 接口，那么怎么做到这点呢？ 首先, 我希望使用的时候看起来像这样： local xxx = require &quot;xxx&quot; (myEnv) 和传统的 require 用法不同，可以在后面追加一个参数 myEnv 。这样的话，每次 xxx 模块被 require 时，它其实被重复运行一次，但会绑定不同的 _ENV 。 其次，既然模块会被反复初始化，那么我们甚至还可以约定，每个这种沙盒封装的模块还可以接收 require 的传入的额外参数。...</summary>
    <author>
        <name>云风</name>
        <uri>http://www.codingnow.com</uri>
    </author>
            <category term="lua与虚拟机" />
    
    <content type="html" xml:lang="en" xml:base="http://blog.codingnow.com/">
        <![CDATA[<p>今天同事提了个需求，他希望可以给部分 lua 代码（由策划编写）做一个沙盒关起来。在 lua 里做沙盒很容易，只需要控制函数的环境就可以了。不过另一个附加需求是，这些代码还可以直接利用 require 加载。</p>

<p>而我们又不想去修改系统的  api 接口，那么怎么做到这点呢？</p>

<p>首先, 我希望使用的时候看起来像这样：</p>

<pre>
local xxx = require "xxx" (myEnv)
</pre>

<p>和传统的 require 用法不同，可以在后面追加一个参数 myEnv 。这样的话，每次 xxx 模块被 require 时，它其实被重复运行一次，但会绑定不同的 <code>_ENV</code> 。</p>

<p>其次，既然模块会被反复初始化，那么我们甚至还可以约定，每个这种沙盒封装的模块还可以接收 require 的传入的额外参数。</p>
]]>
        <![CDATA[<p>做到这点很容易，我们只需要在 package.searchers 里追加一个自定义的 loader 然后并不返回加载的模块 chunk ，而是做一个函数封装。将 chunk 的运行推迟到传入 myEnv 调用之后。</p>

<p>这样，load chunk 本身还是依靠 require 的 package 机制缓存代码的，只是每次调用后，重新绑定 <code>_ENV</code> 生成了一组新实例。</p>

<p>我在 gist 上贴了一组代码实现这个特性：<a href="https://gist.github.com/cloudwu/f9bd2a5f7c22b90cfd2b">延迟绑定环境的 require</a> 。</p>
]]>
    </content>
</entry>

</feed> 

